<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Technology of heaven</title>
  
  <subtitle>Personal homepage</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.sgoldl.top/"/>
  <updated>2018-07-01T14:06:20.990Z</updated>
  <id>http://blog.sgoldl.top/</id>
  
  <author>
    <name>亖 巠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中的闭包</title>
    <link href="http://blog.sgoldl.top/2018/07/01/js_closure/"/>
    <id>http://blog.sgoldl.top/2018/07/01/js_closure/</id>
    <published>2018-07-01T08:04:02.000Z</published>
    <updated>2018-07-01T14:06:20.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。<br>在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    num2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上三个对象 <code>num1</code>, <code>num2</code> 和 <code>fun1</code> 均是全局作用域，这里要注意的是 <strong> 末定义直接赋值的变量自动声明为拥有全局作用域 </strong>；</p><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="string">"我被wrap包裹起来了，wrap外部无法直接访问到我"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//外部无法访问我</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。<br>作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">    fun(a);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？</p><p>我们以fun为例，当我们调用它时，会创建一个包含 <code>arguments</code>，<code>a</code>，<code>b</code>的 <strong> 活动对象 </strong>，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即<code>arguments</code>(当执行流进入，再创建其他的活动对象)。</p><p>在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的<code>arguments</code>对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了<code>arguments中</code>，但他还是属于。</p><p>有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。</p><p>下面我们大致说下这段代码的执行流程：</p><ol><li>在创建<code>foo</code>的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性<code>[[ Scope ]]</code>当中。</li><li>执行<code>foo</code>函数，创建执行环境与活动对象后，取出函数的内部属性<code>[[Scope]]</code>构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。</li><li>执行过程中遇到了<code>fun</code>，从而继续对<code>fun</code>使用上一步的操作。</li><li><code>fun</code>执行结束，移出环境栈。<code>foo</code>因此也执行完毕，继续移出。</li><li>javscript 监听到<code>foo</code>没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。</li></ol><p>作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 <strong> 作用域链 </strong>，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p><h2 id="闭包的特点："><a href="#闭包的特点：" class="headerlink" title="闭包的特点："></a>闭包的特点：</h2><ol><li>作为一个函数变量的一个引用，当函数返回时，其处于激活状态。</li><li>一个闭包就是当一个函数返回时，一个没有释放资源的栈区。<br>其实就是 <strong> 有权访问另一个函数作用域中的变量的函数 </strong>。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说，<strong> 闭包是连接函数内部和外部的桥梁 </strong>。<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2></li><li>访问函数内部的变量。</li><li>让被引用的变量值始终保持在内存中。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(++a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = fn1();</span><br><span class="line"></span><br><span class="line">fn2();        <span class="comment">//输出2</span></span><br><span class="line"></span><br><span class="line">fn2();        <span class="comment">//输出3</span></span><br></pre></td></tr></table></figure><p>在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。</p><p>当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。</p><p>基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除</p><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ol><li>匿名自执行函数<br>我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，<br>比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。<br>除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，<br>比如UI的初始化，那么我们可以使用闭包：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data= &#123;    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : &#123;&#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">     </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">dm</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dm.table.rows; i++)&#123;    </span><br><span class="line">        <span class="keyword">var</span> row = dm.table.rows[i];    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; row.cells; i++)&#123;    </span><br><span class="line">            drawCell(i, j);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">       </span><br><span class="line">&#125;)(data);</span><br></pre></td></tr></table></figure></li></ol><p>我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。</p><ol start="2"><li>结果缓存<br>我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，</li></ol><p>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CachedSearchBox = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,    </span><br><span class="line">        count = [];    </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">        attachSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">            <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;<span class="comment">//如果结果在缓存中    </span></span><br><span class="line">                <span class="keyword">return</span> cache[dsid];<span class="comment">//直接返回缓存中的对象    </span></span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">var</span> fsb = <span class="keyword">new</span> uikit.webctrl.SearchBox(dsid);<span class="comment">//新建    </span></span><br><span class="line">            cache[dsid] = fsb;<span class="comment">//更新缓存    </span></span><br><span class="line">            <span class="keyword">if</span>(count.length &gt; <span class="number">100</span>)&#123;<span class="comment">//保正缓存的大小&lt;=100    </span></span><br><span class="line">                <span class="keyword">delete</span> cache[count.shift()];    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">return</span> fsb;          </span><br><span class="line">        &#125;,    </span><br><span class="line">     </span><br><span class="line">        clearSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">            <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;    </span><br><span class="line">                cache[dsid].clearSelection();      </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;)();    </span><br><span class="line">     </span><br><span class="line">CachedSearchBox.attachSearchBox(<span class="string">"input"</span>);</span><br></pre></td></tr></table></figure></p><p>这样我们在第二次调用的时候，就会从缓存中读取到该对象。</p><ol start="3"><li><p>封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问    </span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"default"</span>;       </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">        getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">            <span class="keyword">return</span> name;    </span><br><span class="line">        &#125;,    </span><br><span class="line">        setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">            name = newName;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;();    </span><br><span class="line">     </span><br><span class="line">print(person.name);<span class="comment">//直接访问，结果为undefined    </span></span><br><span class="line">print(person.getName());    </span><br><span class="line">person.setName(<span class="string">"abruzzi"</span>);    </span><br><span class="line">print(person.getName());    </span><br><span class="line">   </span><br><span class="line">得到结果如下：  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// undefined  </span></span><br><span class="line"><span class="comment">// default  </span></span><br><span class="line"><span class="comment">// abruzzi</span></span><br></pre></td></tr></table></figure></li><li><p>实现类和继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"default"</span>;       </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"Tom"</span>);</span><br><span class="line">alert(p.getName());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Jack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//继承自Person</span></span><br><span class="line">Jack.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//添加私有方法</span></span><br><span class="line">Jack.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello,my name is Jack"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> j = <span class="keyword">new</span> Jack();</span><br><span class="line">j.setName(<span class="string">"Jack"</span>);</span><br><span class="line">j.Say();</span><br><span class="line">alert(j.getName());</span><br></pre></td></tr></table></figure></li></ol><p>我们定义了<code>Person</code>，它就像一个类，我们<code>new</code>一个<code>Person</code>对象，访问它的方法。</p><p>下面我们定义了<code>Jack</code>，继承<code>Person</code>，并添加自己的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且
      
    
    </summary>
    
      <category term="JS" scheme="http://blog.sgoldl.top/categories/JS/"/>
    
    
      <category term="闭包" scheme="http://blog.sgoldl.top/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写博客</title>
    <link href="http://blog.sgoldl.top/2018/07/01/blog/"/>
    <id>http://blog.sgoldl.top/2018/07/01/blog/</id>
    <published>2018-07-01T07:38:40.000Z</published>
    <updated>2018-07-01T07:45:18.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言：你的博客你做主"><a href="#一、前言：你的博客你做主" class="headerlink" title="一、前言：你的博客你做主"></a>一、前言：你的博客你做主</h1><p>在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。<br>其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。</p><h1 id="二、写博客的态度"><a href="#二、写博客的态度" class="headerlink" title="二、写博客的态度"></a>二、写博客的态度</h1><p>你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。</p><h1 id="三、高质量技术博客的特点"><a href="#三、高质量技术博客的特点" class="headerlink" title="三、高质量技术博客的特点"></a>三、高质量技术博客的特点</h1><p>来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言：你的博客你做主&quot;&gt;&lt;a href=&quot;#一、前言：你的博客你做主&quot; class=&quot;headerlink&quot; title=&quot;一、前言：你的博客你做主&quot;&gt;&lt;/a&gt;一、前言：你的博客你做主&lt;/h1&gt;&lt;p&gt;在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏
      
    
    </summary>
    
    
      <category term="First" scheme="http://blog.sgoldl.top/tags/First/"/>
    
  </entry>
  
</feed>
