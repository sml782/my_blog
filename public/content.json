{"meta":{"title":"Technology of heaven","subtitle":"Personal homepage","description":"亖 巠 的个人博客。","author":"亖 巠","url":"http://blog.sgoldl.top"},"pages":[{"title":"分类","date":"2018-06-26T06:26:18.000Z","updated":"2018-06-27T03:16:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.sgoldl.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-26T06:24:55.000Z","updated":"2018-06-27T03:16:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.sgoldl.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript中的闭包","slug":"js_closure","date":"2018-07-01T08:04:02.000Z","updated":"2018-07-01T14:06:20.990Z","comments":true,"path":"2018/07/01/js_closure/","link":"","permalink":"http://blog.sgoldl.top/2018/07/01/js_closure/","excerpt":"","text":"作用域先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域1234var num1 = 1;function fun1 ()&#123; num2 = 2;&#125; 以上三个对象 num1, num2 和 fun1 均是全局作用域，这里要注意的是 末定义直接赋值的变量自动声明为拥有全局作用域 ； 局部作用域123456function wrap()&#123; var obj = \"我被wrap包裹起来了，wrap外部无法直接访问到我\"; function innerFun()&#123; //外部无法访问我 &#125;&#125; 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。123456789function foo()&#123; var a = 12; fun(a); function fun(a)&#123; var b = 8; console.log(a + b); &#125;&#125; foo(); 再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？ 我们以fun为例，当我们调用它时，会创建一个包含 arguments，a，b的 活动对象 ，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即arguments(当执行流进入，再创建其他的活动对象)。 在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的arguments对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了arguments中，但他还是属于。 有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。 下面我们大致说下这段代码的执行流程： 在创建foo的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性[[ Scope ]]当中。 执行foo函数，创建执行环境与活动对象后，取出函数的内部属性[[Scope]]构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。 执行过程中遇到了fun，从而继续对fun使用上一步的操作。 fun执行结束，移出环境栈。foo因此也执行完毕，继续移出。 javscript 监听到foo没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。 作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 作用域链 ，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。 闭包闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。其实就是 有权访问另一个函数作用域中的变量的函数 。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说， 闭包是连接函数内部和外部的桥梁 。闭包的作用 访问函数内部的变量。 让被引用的变量值始终保持在内存中。 12345678910111213function fn1()&#123; var a = 1; return function()&#123; console.log(++a); &#125;&#125;var fn2 = fn1();fn2(); //输出2fn2(); //输出3 在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。 当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。 基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除 闭包的用途 匿名自执行函数我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包：1234567891011121314var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。 结果缓存我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间， 那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。12345678910111213141516171819202122232425var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(\"input\"); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 封装 123456789101112131415161718192021222324var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = \"default\"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(\"abruzzi\"); print(person.getName()); 得到结果如下： // undefined // default // abruzzi 实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = \"default\"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person();p.setName(\"Tom\");alert(p.getName());var Jack = function()&#123;&#125;;//继承自PersonJack.prototype = new Person();//添加私有方法Jack.prototype.Say = function()&#123; alert(\"Hello,my name is Jack\");&#125;;var j = new Jack();j.setName(\"Jack\");j.Say();alert(j.getName()); 我们定义了Person，它就像一个类，我们new一个Person对象，访问它的方法。 下面我们定义了Jack，继承Person，并添加自己的方法。","categories":[{"name":"JS","slug":"JS","permalink":"http://blog.sgoldl.top/categories/JS/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://blog.sgoldl.top/tags/闭包/"}]},{"title":"为什么要写博客","slug":"blog","date":"2018-07-01T07:38:40.000Z","updated":"2018-07-01T07:45:18.918Z","comments":true,"path":"2018/07/01/blog/","link":"","permalink":"http://blog.sgoldl.top/2018/07/01/blog/","excerpt":"","text":"一、前言：你的博客你做主在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。 二、写博客的态度你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。 三、高质量技术博客的特点来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。","categories":[],"tags":[{"name":"First","slug":"First","permalink":"http://blog.sgoldl.top/tags/First/"}]}]}