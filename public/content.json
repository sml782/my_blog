{"meta":{"title":"Technology of heaven","subtitle":"Personal homepage","description":"亖 巠 的个人博客。","author":"亖 巠","url":"http://blog.sgoldl.top"},"pages":[{"title":"分类","date":"2018-06-26T06:26:18.000Z","updated":"2018-06-27T03:16:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.sgoldl.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-26T06:24:55.000Z","updated":"2018-06-27T03:16:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.sgoldl.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript面向对象程序设计","slug":"oop_extend","date":"2018-07-02T15:01:02.000Z","updated":"2018-07-03T15:21:57.587Z","comments":true,"path":"2018/07/02/oop_extend/","link":"","permalink":"http://blog.sgoldl.top/2018/07/02/oop_extend/","excerpt":"","text":"JavaScript面向对象程序设计本文会碰到的知识点：原型、原型链、函数对象、普通对象、继承 读完本文，可以学到 面向对象的基本概念 JavaScript对象属性 理解JavaScript中的函数对象与普通对象 理解prototype和proto 理解原型和原型链 详解原型链相关的Object方法 了解如何用ES5模拟类，以及各种方式的优缺点 了解如何用ES6实现面向对象 一、面向对象的基本概念面向对象也即是OOP，Object Oriented Programming，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例，但是JavaScript中没有类的概念，而是直接使用对象来实现编程。特性： 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。由于JavaScript没有public、private、protected这些关键字，但是可以利用变量的作用域来模拟public和private封装特性123456789101112var insObject = (function() &#123; var _name = 'hello'; // private return &#123; getName: function() &#123; // public return _name; &#125; &#125;&#125;)();insObject._name; // undefinedinsObject.getName(); // hello 这里只是实现了一个简单的版本，private比较好的实现方式可以参考深入理解ES6 145页,protected可以利用ES6的Symbol关键字来实现，这里不展开，有兴趣可以讨论 继承：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写，后面的章节详细描述 二、JavaScript对象属性想弄懂面向对象，是不是先看看对象是啥呢？我们先看一个题目:12[] + &#123;&#125;; // \"[object Object]\"&#123;&#125; + []; // 0 解释：在第一行中，{}出现在+操作符的表达式中，因此被翻译为一个实际的值（一个空object）。而[]被强制转换为””,因此{}也会被强制转换为一个string:&quot;[object Object]&quot;。但在第二行中，{}被翻译为一个独立的{}空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，+ []是一个将[]明确强制转换 为number的表达式，而它的值是0。 2.1 属性对象的属性 Object.prototype Object 的原型对象，不是每个对象都有prototype属性 Object.prototype.proto 不是标准方法，不鼓励使用，每个对象都有proto属性，但是由于浏览器实现方式的不同，proto属性在chrome、firefox中实现了，在IE中并不支持，替代的方法是Object.getPrototypeOf() Object.prototype.constructor：用于创建一个对象的原型，创建对象的构造函数可能大家会有一个疑问，为什么上面那些属性要加上prototype在chrome中打印一下var a = { test: &#39;test&#39; } 属性描述符数据属性： 特性名称 描述 默认值 value 属性的值 undfined writable 是否可以修改属性的值，true表示可以，false表示不可以 true enumerable 属性值是否可枚举，true表示可枚举for-in, false表示不可枚举 true configurable 属性的特性是否可配置，表示能否通过delete删除属性后重新定义属性 true 例子: 访问器属性： 特性名称 描述 默认值 set 设置属性时调用的函数 undefined get 写入属性时调用的函数 undefined configurable 表示能否通过delete删除属性后重新定义属性 true enumerable 表示能否通过for-in循环返回属性 true 访问器属性不能直接定义，一般是通过Object.defineProperty()方法来定义，但是这个方法只支持IE9+， 以前一般用两个非标准方法来实现__defineGetter__()和֖__defineSetter__()例子：123456789101112131415161718var book = &#123; _year: 2004, edition: 1 &#125;;Object.defineProperty(book, \"year\", &#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005; alert(book.edition); 2.2 方法 Object.prototype.toString() 返回对象的字符串表示 Object.prototype.hasOwnProperty() 返回一个布尔值，表示某个对象是否含有指定的属性，而且此属性非原型链继承，也就是说不会检查原型链上的属性 Object.prototype.isPrototypeOf() 返回一个布尔值，表示指定的对象是否在本对象的原型链中 Object.prototype.propertyIsEnumerable() 判断指定属性是否可枚举 Object.prototype.watch() 给对象的某个属性增加监听 Object.prototype.unwatch() 移除对象某个属性的监听 Object.prototype.valueOf() 返回指定对象的原始值 获取和设置属性 Object.defineProperty 定义单个属性 Object.defineProperties 定义多个属性 Object.getOwnPropertyDescriptor 获取属性 Object.assign() 拷贝可枚举属性 （ES6新增） Object.create() 创建对象 Object.entries() 返回一个包含由给定对象所有可枚举属性的属性名和属性值组成的 [属性名，属性值] 键值对的数组，数组中键值对的排列顺序和使用for…in循环遍历该对象时返回的顺序一致 Object.freeze() 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象 Object.getOwnPropertyNames() 返回指定对象的属性名组成的数组 Object.getPrototypeOf 返回该对象的原型 Object.is(value1, value2) 判断两个值是否是同一个值 (ES6 新增) Object.keys() 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致 Object.setPrototypeOf(obj, prototype) 将一个指定的对象的原型设置为另一个对象或者null Object.values 返回一个包含指定对象所有的可枚举属性值的数组，数组中的值顺序和使用for…in循环遍历的顺序一样 2.3 应用如何检测某个属性是否在对象中？ in运算符，判断对象是否包含某个属性，会从对象的实例属性、继承属性里进行检测 123456789101112131415function Dogs(name) &#123; this.name = name&#125;function BigDogs(size) &#123; this.size = size;&#125;BigDogs.prototype = new Dogs();var a = new BigDogs('big');'size' in a;'name' in a;'age' in a; Object.hasOwnProperty()，判断一个对象是否有指定名称的属性，不会检查继承属性 123a.hasOwnProperty('size');a.hasOwnProperty('name');a.hasOwnProperty('age'); Object.propertyIsEnumerable()，判断指定名称的属性是否为实例属性并且是可枚举的 123456789101112131415161718192021222324252627// es6var a = Object.create(&#123;&#125;, &#123; name: &#123; value: 'hello', enumerable: true, &#125;, age: &#123; value: 11, enumerable: false, &#125;&#125;);// es5var b = &#123;&#125;;Object.defineProperties(b, &#123; name: &#123; value: 'hello', enumerable: true, &#125;, age: &#123; value: 11, enumerable: false, &#125; &#125;);a.propertyIsEnumerable('name');a.propertyIsEnumerable('age'); 如何枚举对象的属性，并保证不同了浏览器中的行为是一致的？for/in 语句，可以遍历可枚举的实例属性和继承属性 123456789101112131415161718192021var a = &#123; supername: 'super hello', superage: 'super name',&#125;var b = &#123;&#125;;Object.defineProperties(b, &#123; name: &#123; value: 'hello', enumerable: true, &#125;, age: &#123; value: 11, enumerable: false, &#125; &#125;);Object.setPrototypeOf(b, a); // 设置b的原型是a 等效的是b.__proto__ = afor(pro in b) &#123; console.log(pro); // name, supername, superage&#125; Object.keys()， 返回一个数组，内容是对象可枚举的实例属性名称 12var propertyArray = Object.keys(b); // name Object.getOwnPropertyNames()，返回一个数组，内容是对象所有实例属性，包括可枚举和不可枚举 12var propertyArray = Object.getOwnPropertyNames(b); // name, age 如何判断两个对象是否相等？我只想说，这个问题说简单很简单，说复杂也挺复杂的传送门我们看个简单版的 1234567891011121314151617181920function isEquivalent(a, b) &#123; var aProps = Object.getOwnPropertyNames(a); var bProps = Object.getOwnPropertyNames(b); if (aProps.length != bProps.length)&#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; return true;&#125;// Outputs: trueconsole.log(isEquivalent(&#123;a:1&#125;,&#123;a:1&#125;)); 上面这个函数还有啥问题呢 * 没有对传入参数进行校验，例如判断是否是NaN，或者是其他内置属性 * 没有判断传入对象的construct和prototype * 时间算法复杂度是O(n2) 有同学可能会有疑问，能不能用Object.is，答案是否定的，Object.is简单来说就是在===的基础上特别处理了NaN，+0，-0，保证了-0和+0不相同，Object.is(NaN, NaN)返回true。 对象的深拷贝和浅拷贝其实如果大家理解了上面的那些方法，是很容易写出深拷贝和浅拷贝的代码的，我们先看一下这两者的却别。浅拷贝仅仅是复制引用，拷贝后a === b， 注意Object.assign方法实现的是浅复制（此处有深刻教训！！！）深拷贝这是创建了一个新的对象，然后把旧的对象中的属性和方法拷贝到新的对象中，拷贝后 a !== b深拷贝的实现由很多例子，例如jQuery的extend和lodash中的cloneDeep, clone。jQuery可以使用$.extend(true, {}, …)来实现深拷贝, 但是jQuery无法复制JSON对象之外的对象，例如ES6引入的Map、Set等。而lodash加入的大量的代码来实现ES6新引入的标准对象 三、对象分为函数对象和普通对象 什么是函数对象和普通对象？Object、Function、Array、Date等js的内置对象都是函数对象12345678910111213141516171819202122232425function a1 () &#123;&#125;const a2 = function () &#123;&#125;const a3 = new Function();const b1 = &#123;&#125;;const b2 = new Object();const c1 = [];const c2 = new Array();const d1 = new a1();const d2 = new b1(); // ????const d3 = new c1(); // ????typeof a1;typeof a2;typeof a3;typeof b1;typeof b2;typeof c1;typeof c2;typeof d1; 上面两行报错的原因，是因为构造函数只能由函数来充当，而b1和c1不是Function的实例，所以不能充当构造器 但是只有Function的实例都是函数对象、其他的实例都是普通对象 我们延伸一下，在看个例子123456const e1 = function *()&#123;&#125;;const e2 = new e1();// Uncaught TypeError: e1 is not a constructorconsole.log(e1.constructor) // 是有值的。。。// 规范里面就不能newconst e2 = e1(); GeneratorFunction是一个特殊的函数对象e1.__proto__.__proto__ === Function.prototype e1的原型实际上是一个生成器函数GeneratorFunction，也就是说e1.__proto__ === GeneratorFunction.prototype 这行代码有问题么，啊哈哈哈，GeneratorFunction这个关键字主流的JavaScript还木有暴露出来，所以这个大家理解就好啦 虽然不能直接new e1但是可以new e1.constructor();哈哈哈哈 四、理解prototype和proto 对象类型 prototype proto 函数对象 Yes Yes 普通对象 No Yes 只有函数对象具有prototype这个属性 prototype和__proto__都是js在定义一个对象时的预定义属性 prototype是被实例的__proto__指向 __proto__指向构造函数的prototype1234567891011121314const a = function()&#123;&#125;const b = &#123;&#125;typeof a // functiontypeof b // objecttypeof a.prototype // objecttypeof a.__proto__ // functiontypeof b.prototype // undefinedtypeof b.__proto__ // objecta.__proto__ === Function.prototypeb.__proto__ === Object.prototype 理解了prototype和__proto__之后，我们来看看之前一直说的为什么JavaScript里面都是对象123456789101112131415161718192021222324const a = &#123;&#125;const b = function () &#123;&#125;const c = []const d = new Date()a.__proto__a.__proto__ === Object.prototypeb.__proto__b.__proto__ === Function.prototypec.__proto__c.__proto__ === Array.prototyped.__proto__d.__proto__ === Date.prototypeObject.prototype.__proto__ //nullFunction.prototype.__proto__ === Object.prototypeArray.prototype.__proto__ === Object.prototypeDate.prototype.__proto__ === Object.prototype 延伸一个问题：如何判断一个变量是否是数组？ typeof我们上面已经解释了，这些都是普通对象，普通对象是没有prototype的，他们typeof的值都是object12typeof []typeof &#123;&#125; 从原型来看, 原理就是看Array是否在a的原型链中a的原型链是 Array-&gt;Object12const a = [];Array.prototype.isPrototypeOf(obj); instanceof12const a = [];a instanceof Array 从构造函数入手，但是这个方法和上面的方法都有一问题，不同的框架中创建的数组不会相互共享其prototype属性根据对象的class属性，跨原型调用tostring方法123const a = [];Object.prototype.toString.call(a);// [Object Array] ES5 中所有内置对象的[[Class]]属性的值是由规范定义的，但是 ES6 中已经没有了[[Class]]属性，取代它的是[[NativeBrand]]属性，这个大家有兴趣可以自行去查看规范原理： 如果this的值为undefined,则返回&#39;[object Undefined]&#39;. 如果this的值为null,则返回[object Null]. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 返回三个字符串&#39;[object &#39;, &#39;class&#39;, 以及 &#39;]&#39;连接后的新字符串. 问题？这个一定是正确的么？不正确为啥？提示ES6的Symbol属性Array.isArray()部分浏览器中不兼容 五、理解原型与原型链其实上一节中的prototype和proto就是为了构建原型链而存在的，之前也或多或少的说到了原型链这个概念。 看下面的代码:1234567891011const Dogs = function(name) &#123; this.name = name;&#125;Dogs.prototype.getName = function() &#123; return this.name&#125;const sijing = new Dogs('sijing');console.log(sijing);console.log(sijing.getName()); 这段代码的执行过程 首先创建了一个构造函数Dogs，传入一个参数name，Dogs.prototype也会自动创建 给对象dogs增加了一个方法 通过构造函数Dogs实例化了一个对象sijing 输出sijing的值 可以看到sijing有两个值name和proto,其中proto指向Dogs.prototype 执行getName方法时，在sijing中找不到这个方法，就会继续向着原型链继续往上找，也就是通过proto，然后就找到了getName方法。 这个过程实际上就是原型继承，实际上JavaScript的原型继承就是利用了proto并借助prototype来实现的。12345sijing.__proto__ === Function.prototypeDogs.prototype // 指向什么Dogs.prototype.__proto__ // 指向什么Dogs.prototype.__proto__.__proto__ // 指向什么 上面例子中getName最终是查找到了，那么如果在原型链中一直没查找到，会怎么样？例如console.log(sijing.age)1234567sijing // 是一个对象可以继续sijing.age // 不存在，继续sijing.__proto__ // 是一个对象可以继续sijing.__proto__.age // 不存在，继续sijing.__proto__.__proto__ // 是个对象可以继续sijing.__proto__.__proto__.age // 不存在，继续sijing.__proto__.__proto__.__proto__ null，// 不是对象，到头啦 原型链 的概念其实不重要，重要的是要理解，简单来说，原型链就是利用原型让一个引用类型继承另一个应用类型的属性和方法。 还有三点需要注意的: 任何内置函数对象（类）本身的 _proto_都指向Function的原型对象； 除了Object的原型对象的_proto_指向null，其他所有内置函数对象的原型对象的_proto_都指向object。 所有构造函数的的prototype方法的proto都指向Object.prototype（除了….Object.prototype自身） 如果理解了上面这些内容，大家可以自行描述一下，构造函数、原型和实例之间的关系. 构造函数首字母必须大写，用来区分普通函数，内部使用this指针，指向要生成的实例对象，通过new来生成实例对象。 实例就是通过new一个构造函数产生的对象，它有一个属性[[prototype]]指向原型 原型中有一个属性[[constructor]]，指向构造函数 六、与原型链相关的方法6.1 hasOwnPropertyObject.hasOwnProperty()返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有in操作符，in操作符只要属性存在，不管实在实例中还是原型中，就会返回true。同时使用in和hasOwnProperty就可以判断属性是在原型中还是在实例中12345678910const Dogs = function (age) &#123; this.age = age&#125;Dogs.prototype.getAge = function() &#123; return this.age;&#125;const sijing = new Dogs(14);sijing.hasOwnProperty('age'); 6.2 isPrototypeOfObject.prototype.isPrototypeOf()返回一个布尔值，表示指定的对象是否在本对象的原型链中1234567891011const Dogs = function (age) &#123; this.age = age&#125;Dogs.prototype.getAge = function() &#123; return this.age;&#125;const sijing = new Dogs(11);Object.prototype.isPrototypeOf(Dogs);Dogs.prototype.isPrototypeOf(sijing); 6.3 getPrototypeOfObject.getPrototypeOf返回该对象的原型12345678910const Dogs = function (age) &#123; this.age = age&#125;Dogs.prototype.getAge = function() &#123; return this.age;&#125;const sijing = new Dogs(11);sijing.__proto__ === Object.getPrototypeOf(sijing) 七、ES5 对象继承7.1 原型继承原型继承就是利用 原型链 来实现继承123456789101112131415161718192021function SuperType() &#123; this.supername = 'super';&#125;SuperType.prototype.getSuperName= function()&#123; return this.supername;&#125;function SubType () &#123; this.subname='subname';&#125;SubType.prototype = new SuperType();SubType.prototype.getSubName = function ()&#123; return this.subname;&#125;var instance1 = new SubType();console.log(instance1.getSubName());console.log(instance1.getSuperName()); 需要注意的地方：实现原型继承的时候不要使用对象字面量创建原型方法，因为这样做，会重写原型链。1234567891011121314151617181920212223function SuperType() &#123; this.supername = 'super';&#125;SuperType.prototype.getSuperName= function()&#123; return this.supername;&#125;function SubType () &#123; this.subname='subname';&#125;SubType.prototype = new SuperType();SubType.prototype = &#123; getSubName: function ()&#123; return this.subname; &#125;&#125;var instance1 = new SubType();console.log(instance1.getSubName());console.log(instance1.getSuperName()); // error 上面使用SubType.prototype = {...}之后，SubType的原型就是Object了，而不是SuperType了。 优点：原型定义的属性和方法可以复用缺点： 引用类型的原型属性会被所有实例共享 创建子对象时，不能向父对象的构造函数中传递参数 7.2 构造函数继承123456789101112var a = &#123; name: 'a',&#125;;var name = 'window';var getName = function()&#123; console.log(this.name);&#125;getName() // windowgetName.call(a) // a 执行getName()时，函数体的this指向window，而执行getName.call(a)时，函数体的this指向的是a对象，所以就可以理解啦。接下来我们看如何实现构造函数继承123456789101112131415function SuperType () &#123; this.colors = ['red', 'green'];&#125;function SubType () &#123; // 继承SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push('blue'); console.log(instance1.colors); // red, green, bluevar instance2 = new SubType();console.log(instance2.colors); // red, green SuperType.call(this)这一行代码，实际上意思是在SubType的实例初始化过程中，调用了SuperType的构造函数，因此SubType的每个实例都有colors这个属性 优点：子对象可以传递参数给父对象。123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType(name, age) &#123; name = name || 'hello'; SuperType.call(this, name); this.age = age;&#125;var instance1 = new SubType('scofield', 28);console.log(instance1.name); //console.log(instance1.age); // 需要注意的地方是在调用父对象的构造函数之后，再给子类型中的定义属性，否则会被重写。 缺点：方法都需要在构造函数中定义，难以做到函数的复用，而且在父对象的原型上定义的方法，对于子类型是不可见的。 ??? 为什么不可见1234567891011121314151617181920function SuperType(name) &#123; this.name = name;&#125;SuperType.prototype.getName = function() &#123; return this.name;&#125;SuperType.prototype.prefix = function() &#123; return 'prefix';&#125;function SubType(name) &#123; SuperType.call(this, name);&#125;var instance1 = new SubType('scofield');console.log(instance1.name);console.log(instance1.prefix);console.log(instance1.getName()); // Uncaught TypeError: instance1.getName is not a function 7.3 组合式继承 组合式继承 顾名思义，就是组合两种模式实现JavaScript的继承，借助 原型链 和 构造函数 来实现。这样子在原型上定义方法实现了函数的复用，而且能够保证每个实例都有自己的属性。123456789101112131415161718192021222324252627282930function SuperType (name) &#123; this.name = name; this.con = [];&#125;SuperType.prototype.getName = function() &#123; return this.name;&#125;function SubType (name, age) &#123; SuperType.call(this, name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.getAge = function() &#123; return this.age;&#125;;var instance1 = new SubType('li', 18);instance1.con.push('test1');console.log(instance1.con); // test1console.log(instance1.getAge()); // 18console.log(instance1.getName()); // livar instance2 = new SubType('hang', 18);console.log(instance1.con); // test1console.log(instance1.getAge()); // 18console.log(instance1.getName()); // hang 优点：弥补了 原型继承 和 构造函数 的缺点缺点：父类构造函数调用了两次 7.4 原型式继承原型式继承并没有使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，例如：12345function createObject(o) &#123; function newOrient () &#123;&#125;; newOrient.prototype = o; return new newOrient();&#125; 简单来说createObject函数，对传入的o对象进行的一次浅拷贝。在ES5中新增加了一个方法Object.create(), 它的作用和createObject是一样的，但是只支持IE9+。123456789var Dogs = &#123; name: 'jingmao', age: 1&#125;var BigDogs = Object.create(Dogs);BigDogs.name= 'bigjingmao';BigDogs.size = 'big';console.log(BigDogs.age); 其中Object.create还支持传入第二个参数，参数与Object.defineProperties()方法的格式相同，并且会覆盖原型上的同名属性。 7.5 寄生式继承寄生式继承 其实和 原型式继承 很类似，区别在于，寄生式继承 创建的一个函数把所有的事情做完了，例如给新的对象增加属性和方法。12345678910111213function createAnother(o) &#123; var clone = Object.create(o); clone.size = 'big'; return clone;&#125;var Dogs = &#123; name: 'jingmao', age: 1&#125;var BigDogs = createAnother(Dogs);console.log(BigDogs.size); 7.6 寄生组合式继承到最后一个了，看看我们之前遗留的问题:组合继承 会调用两次父对象的构造函数，并且父类型的属性存在两组，一组在实例上，一组在SubType的原型上。解决这个问题的方法就是 寄生组合式继承。12345678function inheritPrototype(subType, superType)&#123; // 继承父类的原型 var prototype = Object.create(superType.prototype); // 重写被污染的construct prototype.constructor = subType; // 重写子类的原型 subType.prototype = prototype; &#125; 这个函数就是 寄生组合式继承 的最简单的实现方式1234567891011121314151617181920212223function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name); &#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age); &#125;;var instance1 = new SubType('hello', 18);instance1.__proto__.constructor == SubType 可以看到 子类继承了父类的属性和方法，同时属性没有创建在原型链上，因此多个子类不会共享同一个属性。 子类可以动态传递参数给父类 父类构造函数只执行了一次 但是还有一个问题：子类如果在原型上添加方法，必须要在继承之后添加，否则会覆盖原来原型上的方法。但是如果这两个类是已存在的类，就不行了 优化一下：12345678function inheritPrototype(subType, superType)&#123; // 继承父类的原型 var prototype = Object.create(superType.prototype); // 重写被污染的construct prototype.constructor = subType; // 重写子类的原型 subType.prototype = Object.assign(prototype, subType.prototype); &#125; 虽然通过Object.assign来进行copy解决了覆盖原型类型的方法的问题，但是Object.assign只能够拷贝可枚举的方法，而且如果子类本身就继承了一个类，这个办法也不行。 八、ES6 实现继承我们知道了ES5中可以通过原型链来实现继承，ES6提供了extends关键字来实现继承，这相对而言更加清晰和方便，首先看看ES6 Class的语法，此处参考http://es6.ruanyifeng.com/#docs/class","categories":[{"name":"JS","slug":"JS","permalink":"http://blog.sgoldl.top/categories/JS/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://blog.sgoldl.top/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"http://blog.sgoldl.top/tags/继承/"}]},{"title":"JavaScript中的闭包","slug":"js_closure","date":"2018-07-01T08:04:02.000Z","updated":"2018-07-01T14:06:20.990Z","comments":true,"path":"2018/07/01/js_closure/","link":"","permalink":"http://blog.sgoldl.top/2018/07/01/js_closure/","excerpt":"","text":"作用域先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 全局作用域1234var num1 = 1;function fun1 ()&#123; num2 = 2;&#125; 以上三个对象 num1, num2 和 fun1 均是全局作用域，这里要注意的是 末定义直接赋值的变量自动声明为拥有全局作用域 ； 局部作用域123456function wrap()&#123; var obj = \"我被wrap包裹起来了，wrap外部无法直接访问到我\"; function innerFun()&#123; //外部无法访问我 &#125;&#125; 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。123456789function foo()&#123; var a = 12; fun(a); function fun(a)&#123; var b = 8; console.log(a + b); &#125;&#125; foo(); 再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？ 我们以fun为例，当我们调用它时，会创建一个包含 arguments，a，b的 活动对象 ，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即arguments(当执行流进入，再创建其他的活动对象)。 在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的arguments对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了arguments中，但他还是属于。 有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。 下面我们大致说下这段代码的执行流程： 在创建foo的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性[[ Scope ]]当中。 执行foo函数，创建执行环境与活动对象后，取出函数的内部属性[[Scope]]构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。 执行过程中遇到了fun，从而继续对fun使用上一步的操作。 fun执行结束，移出环境栈。foo因此也执行完毕，继续移出。 javscript 监听到foo没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。 作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 作用域链 ，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。 闭包闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。其实就是 有权访问另一个函数作用域中的变量的函数 。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说， 闭包是连接函数内部和外部的桥梁 。闭包的作用 访问函数内部的变量。 让被引用的变量值始终保持在内存中。 12345678910111213function fn1()&#123; var a = 1; return function()&#123; console.log(++a); &#125;&#125;var fn2 = fn1();fn2(); //输出2fn2(); //输出3 在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。 当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。 基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除 闭包的用途 匿名自执行函数我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包：1234567891011121314var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。 结果缓存我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间， 那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。12345678910111213141516171819202122232425var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(\"input\"); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 封装 123456789101112131415161718192021222324var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = \"default\"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(\"abruzzi\"); print(person.getName()); 得到结果如下： // undefined // default // abruzzi 实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = \"default\"; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person();p.setName(\"Tom\");alert(p.getName());var Jack = function()&#123;&#125;;//继承自PersonJack.prototype = new Person();//添加私有方法Jack.prototype.Say = function()&#123; alert(\"Hello,my name is Jack\");&#125;;var j = new Jack();j.setName(\"Jack\");j.Say();alert(j.getName()); 我们定义了Person，它就像一个类，我们new一个Person对象，访问它的方法。 下面我们定义了Jack，继承Person，并添加自己的方法。","categories":[{"name":"JS","slug":"JS","permalink":"http://blog.sgoldl.top/categories/JS/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://blog.sgoldl.top/tags/闭包/"}]},{"title":"为什么要写博客","slug":"blog","date":"2018-07-01T07:38:40.000Z","updated":"2018-07-01T07:45:18.918Z","comments":true,"path":"2018/07/01/blog/","link":"","permalink":"http://blog.sgoldl.top/2018/07/01/blog/","excerpt":"","text":"一、前言：你的博客你做主在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。 二、写博客的态度你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。 三、高质量技术博客的特点来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。","categories":[],"tags":[{"name":"First","slug":"First","permalink":"http://blog.sgoldl.top/tags/First/"}]}]}