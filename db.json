{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/alipay.png","path":"img/alipay.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1532918663926},{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1532680757992},{"_id":"themes/indigo/README.md","hash":"4bf26d9b43bf24b8e0a1a0d058437a347972f5e6","modified":1532680757993},{"_id":"themes/indigo/_config.yml","hash":"c11f64e032f1f5840fdda8492693188d5ae8f6c9","modified":1532683476483},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1532680757993},{"_id":"themes/indigo/package.json","hash":"0ef01e26a514d612fd7fb98b0bab05f9c92b7547","modified":1532680758007},{"_id":"source/_posts/.DS_Store","hash":"f0a4b938a5c9e814f968c5aef6a685a457a44ae6","modified":1533025704594},{"_id":"source/categories/index.md","hash":"9bdf77b9fba386cf142cc799120cad41a8048eff","modified":1532680757992},{"_id":"source/tags/index.md","hash":"88a3afd16c1a4ebf599f29da4161381b29e402e9","modified":1532680757992},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1532680757993},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1532680757994},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1532680757994},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1532680757994},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1532680757994},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1532680758004},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1532680758005},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1532680758005},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1532680758006},{"_id":"themes/indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1532680758006},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1532680758005},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1532680758007},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1532680758006},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1532680758007},{"_id":"themes/indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1532680758006},{"_id":"source/_posts/js/.DS_Store","hash":"9ecbe924814516819354c96f81a6a6ce7d9eaee9","modified":1533190348010},{"_id":"source/_posts/life/blog.md","hash":"a1eda81ab0d572fde0d4890385d94858745ba12c","modified":1532680757989},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1532680757995},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1532680757995},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1532680757995},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1532680757995},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1532680757996},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1532680757996},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1532680757996},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1532680757996},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1532680757996},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1532680757999},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1532680758004},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1532680758004},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1532680758004},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1532680758033},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1532680758034},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1532680758035},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1532680758035},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1532680758035},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1532680758035},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1532680758037},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1532680758038},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1532680758037},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1532680758037},{"_id":"themes/indigo/source/img/alipay.png","hash":"d696d0b770df6f70bd3adad3ce590afe99c6fb08","modified":1532680758034},{"_id":"themes/indigo/source/img/wechat.jpg","hash":"c13e977e1cd72ccd3d15e1e65339ae32ef074b88","modified":1532680758036},{"_id":"source/_posts/js/js_array/2_ unique.md","hash":"8f5918ec645adbd0db38017582e4e593b1696323","modified":1538034568786},{"_id":"source/_posts/js/js_array/1_flatten.md","hash":"8724ef9f7b801f8b8d4e76d8eedb274597893198","modified":1534148363937},{"_id":"source/_posts/js/js_array/1_flatten_extra.md","hash":"774c830a8800acb06b6120b3041b7088623fcc16","modified":1534211359706},{"_id":"source/_posts/js/other/closure.md","hash":"b63e9e3bcf1f463b5c5b1a3ba85cb81e6c334e23","modified":1533094791580},{"_id":"source/_posts/js/other/oop_extend.md","hash":"a1a21ea6e4f2631cbf319b4abc85fdca7cc37135","modified":1533091337508},{"_id":"source/_posts/js/performance/debounce_throttle.md","hash":"bbb67ade97c7c66f775c0f53b2f5665ea71505a1","modified":1533116253174},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1532680757997},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1532680757997},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1532680757997},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1532680757997},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1532680757997},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1532680757998},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1532680757998},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1532680757998},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1532680757999},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1532680757999},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1532680757999},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1532680757999},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1532680758000},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"bcc3bd7a9023d71778f15e98c88552335ae69a69","modified":1532680758000},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1532680758000},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1532680758001},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1532680758001},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1532680758001},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1532680758001},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1532680758002},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1532680758002},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1532680758002},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1532680758003},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1532680758003},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1532680758003},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1532680758003},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1532680758008},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1532680758009},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1532680758009},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1532680758008},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1532680758009},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1532680758010},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1532680758010},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1532680758010},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1532680758011},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1532680758011},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1532680758011},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1532680758011},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1532680758012},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1532680758012},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1532680758012},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1532680758012},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1532680758013},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1533110137649},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1532680758009},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1532680758022},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1532680758023},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1532680758023},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1532680758024},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1532680758026},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1532680758026},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1532680758026},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1532680758028},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1532680758029},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1532680758028},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1532680758031},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1532680758031},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1532680758030},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1532680758033},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1532680758032},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1532680758021},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1532680758021},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1532680758023},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1532680758025},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1532680758028},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1532680758030},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1532680758032},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1532680758015},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1532680758016},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1532680758020},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1532680758018}],"Category":[{"name":"JS","_id":"cjmka46p800070qr45b2yhwv2"}],"Data":[],"Page":[{"title":"标签","comments":0,"date":"2018-06-26T06:24:55.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ncomments: false\ndate: 2018-06-26 14:24:55\nlayout: tags\n---\n","updated":"2018-07-27T08:39:17.992Z","path":"tags/index.html","_id":"cjmka46n000000qr4zssezfqo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","comments":0,"date":"2018-06-26T06:26:18.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ncomments: false\ndate: 2018-06-26 14:26:18\nlayout: categories\n---\n","updated":"2018-07-27T08:39:17.992Z","path":"categories/index.html","_id":"cjmka46n200010qr4wx8l1335","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"为什么要写博客","date":"2018-07-01T07:38:40.000Z","_content":"# 一、前言：你的博客你做主\n\n在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。 \n其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。\n\n# 二、写博客的态度\n\n你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。\n\n# 三、高质量技术博客的特点\n\n来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。","source":"_posts/life/blog.md","raw":"---\ntitle: 为什么要写博客\ndate: 2018-07-01 15:38:40\ntags: [ First ]\n---\n# 一、前言：你的博客你做主\n\n在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。 \n其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。\n\n# 二、写博客的态度\n\n你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。\n\n# 三、高质量技术博客的特点\n\n来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。","slug":"life/blog","published":1,"updated":"2018-07-27T08:39:17.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46of00020qr4od30e23w","content":"<h1 id=\"一、前言：你的博客你做主\"><a href=\"#一、前言：你的博客你做主\" class=\"headerlink\" title=\"一、前言：你的博客你做主\"></a>一、前言：你的博客你做主</h1><p>在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。<br>其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。</p>\n<h1 id=\"二、写博客的态度\"><a href=\"#二、写博客的态度\" class=\"headerlink\" title=\"二、写博客的态度\"></a>二、写博客的态度</h1><p>你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。</p>\n<h1 id=\"三、高质量技术博客的特点\"><a href=\"#三、高质量技术博客的特点\" class=\"headerlink\" title=\"三、高质量技术博客的特点\"></a>三、高质量技术博客的特点</h1><p>来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、前言：你的博客你做主\"><a href=\"#一、前言：你的博客你做主\" class=\"headerlink\" title=\"一、前言：你的博客你做主\"></a>一、前言：你的博客你做主</h1><p>在我刚入行时，还是个普通人，毕竟我的专业也是学这个的，每天浏览各种技术博客和论坛。可时间长了，我就发现，你不用Google真的就搜不出来你想要的东西，即使搜出来了，博客上所写的内容，零零散散，也不能满足你，你还要去搜，去找，等到各方面找全了，开始实际作战了，本地应用又会出现问题（很好理解，你本地的各种环境可能和网上不一样），为了解决问题，你还是会去搜索找博客，结果呢还是像上面一样，时间都浪费在了搜集资料和整理上，大家的项目都是公司项目，这边你还没等处理完问题，老板就来催了，加班自然跑不了。<br>其实没有所谓的好的博客，你自己写的博客，排不排版，贴不贴图，公不公开，都是随你，你开心就好。但是真的想要访问量高、评论数多，充分显示出你的专业性，还是需要下一番功夫去思考的。所以本文是一篇专业水文，建议在各种碎片化时间服用。</p>\n<h1 id=\"二、写博客的态度\"><a href=\"#二、写博客的态度\" class=\"headerlink\" title=\"二、写博客的态度\"></a>二、写博客的态度</h1><p>你为什么想写博客？给别人看？给自己看？还有吗？你写博客时意识到自己在做什么吗？你会说码字啊。呵呵。在我看来，你写博客的过程就是在创造资源，为世界上成PB量级的数据做贡献。只不过这个资源有好有坏。如果谈到资源，就会涉及管理、使用、销毁等等。你不止是在写博客，而是在梳理你的知识技能，构建你的知识体系，在创造属于你自己的知识宝库。有那样一句玩笑话：一入IT深似海，从此妹子是路人，也侧面说明了IT行业知识、技术相当广和深，我们更需要通过博客进行知识的积累。只是你没意识到这一点，所以你才会随随便便写了两篇博客，然后就放弃了。如果你能坚持的去写一些高质量的博客，相信我，无论你何时回翻看这些博客，你都会有一种自豪感。</p>\n<h1 id=\"三、高质量技术博客的特点\"><a href=\"#三、高质量技术博客的特点\" class=\"headerlink\" title=\"三、高质量技术博客的特点\"></a>三、高质量技术博客的特点</h1><p>来源权威，有因有果，可迭代，互动性，不啰嗦，最好是原创。</p>\n"},{"title":"JS数组专题1️⃣ ➖ 数组扁平化","description":"数组扁平化","date":"2018-08-06T08:30:18.000Z","published":1,"_content":"# 一、什么是数组扁平化\n\n1. 扁平化，顾名思义就是减少复杂性装饰，使其事物本身更简洁、简单，突出主题。\n2. 数组扁平化，对着上面意思套也知道了，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层的数组。\n\n**Ps**: `flatten` 可以使数组扁平化，效果就会如下：\n\n```js\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr)); // [1, 2, 3, 4]\n```\n\n> 从中可以看出，使用 `flatten` 处理后的数组只有一层，下面我们来试着实现一下。\n\n# 二、简单实现\n\n## 2.1 普通递归\n\n* 这是最容易想到的方法，简单，清晰！\n\n```js\n/* ES6 */\nconst flatten = (arr) => {\n  let result = [];\n  arr.forEach((item, i, arr) => {\n    if (Array.isArray(item)) {\n      result = result.concat(flatten(item));\n    } else {\n      result.push(arr[i])\n    }\n  })\n  return result;\n};\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\nfunction flatten(arr) {\n  var result = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (Array.isArray(arr[i])) {\n      result = result.concat(flatten(arr[i]))\n    }\n    else {\n      result.push(arr[i])\n    }\n  }\n  return result;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.2 `toString()`\n\n* 该方法是利用 `toString` 把数组变成以逗号分隔的字符串，然后遍历数组把每一项再变回原来的类型。\n\n先来看下 `toString` 是怎么把数组变成字符串的\n\n```js\n[1, [2, 3, [4]]].toString()\n// \"1,2,3,4\"\n```\n\n完整的展示\n\n```js\n/* ES6 */\nconst flatten = (arr) => arr.toString().split(',').map((item) => +item);\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\nfunction flatten(arr) {\n  return arr.toString().split(',').map(function(item){\n    return +item;\n  });\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n> 这种方法使用的场景却非常有限，必须数组中元素全部都是 `Number`。\n> 也可以全部都为 `String`，具体实现大家自己体会。\n\n## 2.3 `[].concat.apply` + `some`\n\n* 利用 `arr.some` 判断当数组中还有数组的话，循环调用 `flatten` 扁平函数(利用 `[].concat.apply`扁平), 用 `concat` 连接，最终返回 `arr`;\n\n```js\n/* ES6 */\nconst flatten = (arr) => {\n  while (arr.some(item => Array.isArray(item))){\n    arr = [].concat.apply([], arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\n/**\n* 封装Array.some\n* @param {function} callback    - 回调函数\n* @param {any}      currentThis - 回调函数中this指向\n*/\nArray.prototype.some = function (callback, currentThis){\n  let context = this;\n  let flag = false;\n  currentThis = currentThis || this;\n  for (var i = 0, len = context.length; i < len; i++) {\n    const res = callback.call(currentThis, context[i], i, context);\n    if (res) {\n      flag = true;\n    } else if (!flag) {\n      flag = false;\n    }\n  }\n  return flag;\n}\n\nfunction flatten(arr){\n  while(arr.some(item => Array.isArray(item))){\n    arr = [].concat.apply([], arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.4 `reduce`\n\n* `reduce` 本身就是一个迭代循环器，通常用于累加，所以根据这一特点有以下：\n\n```js\nfunction flatten(arr){\n  return arr.reduce(function(prev, cur){\n    return prev.concat(Array.isArray(cur) ? flatten(cur) : cur)\n  }, [])\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.5 ES6 中的 解构运算符 `...`\n\n* `...` 每次只能展开最外层的数组，被 `[].concat` 后，`arr` 就扁平化一次。\n\n```js\nfunction flatten(arr){\n  while(arr.some(item => Array.isArray(item))){\n    arr = [].concat(...arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n**番外篇将给大家讲解 `lodash` 中 `flatten` 的实现源码，感谢大家阅读！**\n","source":"_posts/js/js_array/1_flatten.md","raw":"---\ntitle: JS数组专题1️⃣ ➖ 数组扁平化\ndescription: 数组扁平化\ndate: 2018-08-06 16:30:18\ntags: [ 数组, 数组扁平化 ]\ncategories: [ JS ]\npublished: true\n---\n# 一、什么是数组扁平化\n\n1. 扁平化，顾名思义就是减少复杂性装饰，使其事物本身更简洁、简单，突出主题。\n2. 数组扁平化，对着上面意思套也知道了，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层的数组。\n\n**Ps**: `flatten` 可以使数组扁平化，效果就会如下：\n\n```js\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr)); // [1, 2, 3, 4]\n```\n\n> 从中可以看出，使用 `flatten` 处理后的数组只有一层，下面我们来试着实现一下。\n\n# 二、简单实现\n\n## 2.1 普通递归\n\n* 这是最容易想到的方法，简单，清晰！\n\n```js\n/* ES6 */\nconst flatten = (arr) => {\n  let result = [];\n  arr.forEach((item, i, arr) => {\n    if (Array.isArray(item)) {\n      result = result.concat(flatten(item));\n    } else {\n      result.push(arr[i])\n    }\n  })\n  return result;\n};\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\nfunction flatten(arr) {\n  var result = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (Array.isArray(arr[i])) {\n      result = result.concat(flatten(arr[i]))\n    }\n    else {\n      result.push(arr[i])\n    }\n  }\n  return result;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.2 `toString()`\n\n* 该方法是利用 `toString` 把数组变成以逗号分隔的字符串，然后遍历数组把每一项再变回原来的类型。\n\n先来看下 `toString` 是怎么把数组变成字符串的\n\n```js\n[1, [2, 3, [4]]].toString()\n// \"1,2,3,4\"\n```\n\n完整的展示\n\n```js\n/* ES6 */\nconst flatten = (arr) => arr.toString().split(',').map((item) => +item);\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\nfunction flatten(arr) {\n  return arr.toString().split(',').map(function(item){\n    return +item;\n  });\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n> 这种方法使用的场景却非常有限，必须数组中元素全部都是 `Number`。\n> 也可以全部都为 `String`，具体实现大家自己体会。\n\n## 2.3 `[].concat.apply` + `some`\n\n* 利用 `arr.some` 判断当数组中还有数组的话，循环调用 `flatten` 扁平函数(利用 `[].concat.apply`扁平), 用 `concat` 连接，最终返回 `arr`;\n\n```js\n/* ES6 */\nconst flatten = (arr) => {\n  while (arr.some(item => Array.isArray(item))){\n    arr = [].concat.apply([], arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n```js\n/* ES5 */\n/**\n* 封装Array.some\n* @param {function} callback    - 回调函数\n* @param {any}      currentThis - 回调函数中this指向\n*/\nArray.prototype.some = function (callback, currentThis){\n  let context = this;\n  let flag = false;\n  currentThis = currentThis || this;\n  for (var i = 0, len = context.length; i < len; i++) {\n    const res = callback.call(currentThis, context[i], i, context);\n    if (res) {\n      flag = true;\n    } else if (!flag) {\n      flag = false;\n    }\n  }\n  return flag;\n}\n\nfunction flatten(arr){\n  while(arr.some(item => Array.isArray(item))){\n    arr = [].concat.apply([], arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.4 `reduce`\n\n* `reduce` 本身就是一个迭代循环器，通常用于累加，所以根据这一特点有以下：\n\n```js\nfunction flatten(arr){\n  return arr.reduce(function(prev, cur){\n    return prev.concat(Array.isArray(cur) ? flatten(cur) : cur)\n  }, [])\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n## 2.5 ES6 中的 解构运算符 `...`\n\n* `...` 每次只能展开最外层的数组，被 `[].concat` 后，`arr` 就扁平化一次。\n\n```js\nfunction flatten(arr){\n  while(arr.some(item => Array.isArray(item))){\n    arr = [].concat(...arr);\n  }\n  return arr;\n}\n\nconst arr = [1, [2, [3, 4]]];\nconsole.log(flatten(arr));\n```\n\n**番外篇将给大家讲解 `lodash` 中 `flatten` 的实现源码，感谢大家阅读！**\n","slug":"js/js_array/1_flatten","updated":"2018-08-13T08:19:23.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46p700060qr41tvnr969","content":"<h1 id=\"一、什么是数组扁平化\"><a href=\"#一、什么是数组扁平化\" class=\"headerlink\" title=\"一、什么是数组扁平化\"></a>一、什么是数组扁平化</h1><ol>\n<li>扁平化，顾名思义就是减少复杂性装饰，使其事物本身更简洁、简单，突出主题。</li>\n<li>数组扁平化，对着上面意思套也知道了，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层的数组。</li>\n</ol>\n<p><strong>Ps</strong>: <code>flatten</code> 可以使数组扁平化，效果就会如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr)); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从中可以看出，使用 <code>flatten</code> 处理后的数组只有一层，下面我们来试着实现一下。</p>\n</blockquote>\n<h1 id=\"二、简单实现\"><a href=\"#二、简单实现\" class=\"headerlink\" title=\"二、简单实现\"></a>二、简单实现</h1><h2 id=\"2-1-普通递归\"><a href=\"#2-1-普通递归\" class=\"headerlink\" title=\"2.1 普通递归\"></a>2.1 普通递归</h2><ul>\n<li>这是最容易想到的方法，简单，清晰！</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(item)) &#123;</span><br><span class=\"line\">      result = result.concat(flatten(item));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(arr[i])) &#123;</span><br><span class=\"line\">      result = result.concat(flatten(arr[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-toString\"><a href=\"#2-2-toString\" class=\"headerlink\" title=\"2.2 toString()\"></a>2.2 <code>toString()</code></h2><ul>\n<li>该方法是利用 <code>toString</code> 把数组变成以逗号分隔的字符串，然后遍历数组把每一项再变回原来的类型。</li>\n</ul>\n<p>先来看下 <code>toString</code> 是怎么把数组变成字符串的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>, [<span class=\"number\">4</span>]]].toString()</span><br><span class=\"line\"><span class=\"comment\">// \"1,2,3,4\"</span></span><br></pre></td></tr></table></figure>\n<p>完整的展示</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> +item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> +item;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方法使用的场景却非常有限，必须数组中元素全部都是 <code>Number</code>。<br>也可以全部都为 <code>String</code>，具体实现大家自己体会。</p>\n</blockquote>\n<h2 id=\"2-3-concat-apply-some\"><a href=\"#2-3-concat-apply-some\" class=\"headerlink\" title=\"2.3 [].concat.apply + some\"></a>2.3 <code>[].concat.apply</code> + <code>some</code></h2><ul>\n<li>利用 <code>arr.some</code> 判断当数组中还有数组的话，循环调用 <code>flatten</code> 扁平函数(利用 <code>[].concat.apply</code>扁平), 用 <code>concat</code> 连接，最终返回 <code>arr</code>;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat.apply([], arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 封装Array.some</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;function&#125; callback    - 回调函数</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;any&#125;      currentThis - 回调函数中this指向</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.some = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback, currentThis</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  currentThis = currentThis || <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = context.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = callback.call(currentThis, context[i], i, context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat.apply([], arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-reduce\"><a href=\"#2-4-reduce\" class=\"headerlink\" title=\"2.4 reduce\"></a>2.4 <code>reduce</code></h2><ul>\n<li><code>reduce</code> 本身就是一个迭代循环器，通常用于累加，所以根据这一特点有以下：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev.concat(<span class=\"built_in\">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-5-ES6-中的-解构运算符\"><a href=\"#2-5-ES6-中的-解构运算符\" class=\"headerlink\" title=\"2.5 ES6 中的 解构运算符 ...\"></a>2.5 ES6 中的 解构运算符 <code>...</code></h2><ul>\n<li><code>...</code> 每次只能展开最外层的数组，被 <code>[].concat</code> 后，<code>arr</code> 就扁平化一次。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat(...arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<p><strong>番外篇将给大家讲解 <code>lodash</code> 中 <code>flatten</code> 的实现源码，感谢大家阅读！</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、什么是数组扁平化\"><a href=\"#一、什么是数组扁平化\" class=\"headerlink\" title=\"一、什么是数组扁平化\"></a>一、什么是数组扁平化</h1><ol>\n<li>扁平化，顾名思义就是减少复杂性装饰，使其事物本身更简洁、简单，突出主题。</li>\n<li>数组扁平化，对着上面意思套也知道了，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层的数组。</li>\n</ol>\n<p><strong>Ps</strong>: <code>flatten</code> 可以使数组扁平化，效果就会如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr)); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从中可以看出，使用 <code>flatten</code> 处理后的数组只有一层，下面我们来试着实现一下。</p>\n</blockquote>\n<h1 id=\"二、简单实现\"><a href=\"#二、简单实现\" class=\"headerlink\" title=\"二、简单实现\"></a>二、简单实现</h1><h2 id=\"2-1-普通递归\"><a href=\"#2-1-普通递归\" class=\"headerlink\" title=\"2.1 普通递归\"></a>2.1 普通递归</h2><ul>\n<li>这是最容易想到的方法，简单，清晰！</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, i, arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(item)) &#123;</span><br><span class=\"line\">      result = result.concat(flatten(item));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(arr[i])) &#123;</span><br><span class=\"line\">      result = result.concat(flatten(arr[i]))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(arr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-toString\"><a href=\"#2-2-toString\" class=\"headerlink\" title=\"2.2 toString()\"></a>2.2 <code>toString()</code></h2><ul>\n<li>该方法是利用 <code>toString</code> 把数组变成以逗号分隔的字符串，然后遍历数组把每一项再变回原来的类型。</li>\n</ul>\n<p>先来看下 <code>toString</code> 是怎么把数组变成字符串的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>, [<span class=\"number\">4</span>]]].toString()</span><br><span class=\"line\"><span class=\"comment\">// \"1,2,3,4\"</span></span><br></pre></td></tr></table></figure>\n<p>完整的展示</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> +item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> +item;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方法使用的场景却非常有限，必须数组中元素全部都是 <code>Number</code>。<br>也可以全部都为 <code>String</code>，具体实现大家自己体会。</p>\n</blockquote>\n<h2 id=\"2-3-concat-apply-some\"><a href=\"#2-3-concat-apply-some\" class=\"headerlink\" title=\"2.3 [].concat.apply + some\"></a>2.3 <code>[].concat.apply</code> + <code>some</code></h2><ul>\n<li>利用 <code>arr.some</code> 判断当数组中还有数组的话，循环调用 <code>flatten</code> 扁平函数(利用 <code>[].concat.apply</code>扁平), 用 <code>concat</code> 连接，最终返回 <code>arr</code>;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES6 */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> flatten = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat.apply([], arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ES5 */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 封装Array.some</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;function&#125; callback    - 回调函数</span></span><br><span class=\"line\"><span class=\"comment\">* @param &#123;any&#125;      currentThis - 回调函数中this指向</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.some = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback, currentThis</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  currentThis = currentThis || <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = context.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = callback.call(currentThis, context[i], i, context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat.apply([], arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-reduce\"><a href=\"#2-4-reduce\" class=\"headerlink\" title=\"2.4 reduce\"></a>2.4 <code>reduce</code></h2><ul>\n<li><code>reduce</code> 本身就是一个迭代循环器，通常用于累加，所以根据这一特点有以下：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prev.concat(<span class=\"built_in\">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-5-ES6-中的-解构运算符\"><a href=\"#2-5-ES6-中的-解构运算符\" class=\"headerlink\" title=\"2.5 ES6 中的 解构运算符 ...\"></a>2.5 ES6 中的 解构运算符 <code>...</code></h2><ul>\n<li><code>...</code> 每次只能展开最外层的数组，被 <code>[].concat</code> 后，<code>arr</code> 就扁平化一次。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(arr.some(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(item)))&#123;</span><br><span class=\"line\">    arr = [].concat(...arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>\n<p><strong>番外篇将给大家讲解 <code>lodash</code> 中 <code>flatten</code> 的实现源码，感谢大家阅读！</strong></p>\n"},{"title":"JS数组专题1️⃣_番外篇 ➖ lodash中的flatten","description":"lodash中的flatten","date":"2018-08-12T08:19:18.000Z","published":1,"_content":"> 专题一已经给大家介绍了数组扁平化，本篇将给大家介绍 `lodash` 中的 `flatten` 是如何实现的。\n\n# 一、lodash源码\n\n## 1.基础函数\n\n* `isFlattenable.js`\n\n```js\n// isFlattenable.js\nimport isArguments from '../isArguments.js' // 检查 value 是否是一个类 arguments 对象，在本篇不予讲解。\n\n// ES6中内置属性，可用于判断数组是否可展开. 具体可见 MDN\nconst spreadableSymbol = Symbol.isConcatSpreadable;\n/*\nvalue[Symbol.isConcatSpreadable] === true时可展开，\n可手动设置为false value[Symbol.isConcatSpreadable] = false\n*/\n\n/**\n * 检查值是否可展开.\n *\n * @private\n * @param {*} value 要检查的值.\n * @returns {boolean} 返回布尔值，可展开 -> true, 不可展开 -> false.\n */\nfunction isFlattenable(value) {\n  return Array.isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n```\n\n* `baseFlatten.js`\n\n```js\n// baseFlatten.js\nimport isFlattenable from './isFlattenable.js' // 是否可以扁平化\n\n/**\n * _.flatten 的基本实现与支持限制扁平化。\n *\n * @private\n * @param {Array} array 需要扁平化的数组.\n * @param {number} depth 扁平化的深度.\n * @param {boolean} [predicate=isFlattenable] 该函数每次迭代判断是否可展开操作.\n * @param {boolean} [isStrict] 是否可通过 predicate 检查.\n * @param {Array} [result=[]] 初始结果数组.\n * @returns {Array} 返回新的扁平数组.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  if (array == null) {\n    return result; // 如果数组为空，则直接返回初始化结果\n  }\n\n  for (const value of array) {\n    if (depth > 0 && predicate(value)) { // 判断深度和是否可展开\n      if (depth > 1) {\n        // 如果深度大于1，继续递归扁平化数组.\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        // 否则 push 进结果集中\n        result.push(...value);\n      }\n    } else if (!isStrict) {\n      // 如果不检查数组，直接不展开放进结果集中\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n```\n\n* map.js\n\n```js\n/**\n * 通过 iteratee 操作的每个元素，创建一个新数组.\n * iteratee 有三个参数 (value, index, array).\n *\n * @since 5.0.0\n * @category Array\n * @param {Array} array 要操作的数组.\n * @param {Function} iteratee 操作函数.\n * @returns {Array} 返回新的数组.\n * @example\n *\n * function square(n) {\n *   return n * n\n * }\n *\n * map([4, 8], square)\n * // => [16, 64]\n */\nfunction map(array, iteratee) {\n  let index = -1;\n  const length = array == null ? 0 : array.length;\n  const result = new Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default map;\n```\n\n## 2.运用函数\n\n实际上所有的 `flatten` 都是依赖上面的基础函数。\n\n* `flatten.js`\n\n```js\n// flatten.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/**\n * 扁平化一级数组.\n *\n * @since 0.1.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep, flattenDepth\n * @example\n *\n * flatten([1, [2, [3, [4]], 5]])\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  const length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n```\n\n* flattenDeep.js\n\n```js\n// flattenDeep.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/** 使用一个无限大的数值. */\nconst INFINITY = 1 / 0\n\n/**\n * 递归最终扁平为只有一级的数组.\n *\n * @since 3.0.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flatten, flattenDepth\n * @example\n *\n * flattenDeep([1, [2, [3, [4]], 5]])\n * // => [1, 2, 3, 4, 5]\n */\nfunction flattenDeep(array) {\n  const length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, INFINITY) : [];\n}\n\nexport default flattenDeep;\n```\n\n* flattenDepth.js\n\n```js\n// flattenDepth.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/**\n * 递归将数组扁平化至指定深度.\n *\n * @since 4.4.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @param {number} [depth=1] 最大扁平化深度.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep\n * @example\n *\n * const array = [1, [2, [3, [4]], 5]]\n *\n * flattenDepth(array, 1)\n * // => [1, 2, [3, [4]], 5]\n *\n * flattenDepth(array, 2)\n * // => [1, 2, 3, [4], 5]\n */\nfunction flattenDepth(array, depth) {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : +depth; // 没有depth参数时为1，有的时候转化为正数.\n  return baseFlatten(array, depth);\n}\n\nexport default flattenDepth;\n```\n\n* flatMap.js\n\n```js\nimport baseFlatten from './.internal/baseFlatten.js'\nimport map from './map.js' // 封装map函数\n\n/**\n * 使用 map 重新创建数组，然后使用 baseFlatten 扁平化一级.\n *\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection 将处理的数组.\n * @param {Function} iteratee 数组遍历处理函数\n * @returns {Array} 返回新的扁平化后的数组.\n * @see flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues\n * @example\n *\n * function duplicate(n) {\n *   return [n, n]\n * }\n *\n * flatMap([1, 2], duplicate)\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n```\n\n* flatMapDeep.js\n\n和 `flattenDeep.js` 类似，只不过扁平化之前和 `flatMap.js` 一样先 `map` 一遍数组，然后进行扁平化处理。\n\n* flatMapDepth.js\n\n和 `flattenDepth.js` 类似，只不过扁平化之前和 `flatMap.js` 一样先 `map` 一遍数组，然后进行扁平化处理。\n\n# 二、数组原生函数\n\n## 1.`Array.prototype.flat`\n\n* 本函数和 `flattenDepth` 类似，只不过是多了一个删除空项的功能，挂载在 `Array` 实例下的函数。\n\n```js\n// 判断是否可展开\nfunction isFlattenable(value) {\n  const spreadableSymbol = Symbol.isConcatSpreadable;\n  return Array.isArray(value) || _.isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n// 判断空\nfunction isEmpty(value) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  return false;\n}\n\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  if (array == null) {\n    return result; // 如果数组为空，则直接返回初始化结果\n  }\n\n  for (const value of array) {\n    if (depth > 0 && predicate(value)) { // 判断深度和是否可展开\n      if (depth > 1) {\n        // 如果深度大于1，继续递归扁平化数组.\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        // 否则 push 进结果集中\n        result.push(...value);\n      }\n    } else if (!isStrict && !isEmpty(value)) {\n      // 如果不检查数组并且不为空，直接不展开放进结果集中\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * 递归将数组扁平化至指定深度.\n *\n * @param {number} [depth=1] 最大扁平化深度.\n * @returns {Array} 返回扁平化后的数组.\n * @example\n *\n * const array = [1, [2, [3, [4]], 5]]\n *\n * array.flat(1)\n * // => [1, 2, [3, [4]], 5]\n *\n * array.flat(2)\n * // => [1, 2, 3, [4], 5]\n */\nArray.prototype.flat = function flattenDepth(depth) {\n  const array = this;\n  const length = array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : +depth; // 没有depth参数时为1，有的时候转化为正数.\n  return baseFlatten(array, depth);\n}\n```\n","source":"_posts/js/js_array/1_flatten_extra.md","raw":"---\ntitle: JS数组专题1️⃣_番外篇 ➖ lodash中的flatten\ndescription: lodash中的flatten\ndate: 2018-08-12 16:19:18\ntags: [ 数组, 数组扁平化, lodash源码 ]\ncategories: [ JS ]\npublished: true\n---\n> 专题一已经给大家介绍了数组扁平化，本篇将给大家介绍 `lodash` 中的 `flatten` 是如何实现的。\n\n# 一、lodash源码\n\n## 1.基础函数\n\n* `isFlattenable.js`\n\n```js\n// isFlattenable.js\nimport isArguments from '../isArguments.js' // 检查 value 是否是一个类 arguments 对象，在本篇不予讲解。\n\n// ES6中内置属性，可用于判断数组是否可展开. 具体可见 MDN\nconst spreadableSymbol = Symbol.isConcatSpreadable;\n/*\nvalue[Symbol.isConcatSpreadable] === true时可展开，\n可手动设置为false value[Symbol.isConcatSpreadable] = false\n*/\n\n/**\n * 检查值是否可展开.\n *\n * @private\n * @param {*} value 要检查的值.\n * @returns {boolean} 返回布尔值，可展开 -> true, 不可展开 -> false.\n */\nfunction isFlattenable(value) {\n  return Array.isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nexport default isFlattenable;\n```\n\n* `baseFlatten.js`\n\n```js\n// baseFlatten.js\nimport isFlattenable from './isFlattenable.js' // 是否可以扁平化\n\n/**\n * _.flatten 的基本实现与支持限制扁平化。\n *\n * @private\n * @param {Array} array 需要扁平化的数组.\n * @param {number} depth 扁平化的深度.\n * @param {boolean} [predicate=isFlattenable] 该函数每次迭代判断是否可展开操作.\n * @param {boolean} [isStrict] 是否可通过 predicate 检查.\n * @param {Array} [result=[]] 初始结果数组.\n * @returns {Array} 返回新的扁平数组.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  if (array == null) {\n    return result; // 如果数组为空，则直接返回初始化结果\n  }\n\n  for (const value of array) {\n    if (depth > 0 && predicate(value)) { // 判断深度和是否可展开\n      if (depth > 1) {\n        // 如果深度大于1，继续递归扁平化数组.\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        // 否则 push 进结果集中\n        result.push(...value);\n      }\n    } else if (!isStrict) {\n      // 如果不检查数组，直接不展开放进结果集中\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nexport default baseFlatten;\n```\n\n* map.js\n\n```js\n/**\n * 通过 iteratee 操作的每个元素，创建一个新数组.\n * iteratee 有三个参数 (value, index, array).\n *\n * @since 5.0.0\n * @category Array\n * @param {Array} array 要操作的数组.\n * @param {Function} iteratee 操作函数.\n * @returns {Array} 返回新的数组.\n * @example\n *\n * function square(n) {\n *   return n * n\n * }\n *\n * map([4, 8], square)\n * // => [16, 64]\n */\nfunction map(array, iteratee) {\n  let index = -1;\n  const length = array == null ? 0 : array.length;\n  const result = new Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default map;\n```\n\n## 2.运用函数\n\n实际上所有的 `flatten` 都是依赖上面的基础函数。\n\n* `flatten.js`\n\n```js\n// flatten.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/**\n * 扁平化一级数组.\n *\n * @since 0.1.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep, flattenDepth\n * @example\n *\n * flatten([1, [2, [3, [4]], 5]])\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  const length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nexport default flatten;\n```\n\n* flattenDeep.js\n\n```js\n// flattenDeep.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/** 使用一个无限大的数值. */\nconst INFINITY = 1 / 0\n\n/**\n * 递归最终扁平为只有一级的数组.\n *\n * @since 3.0.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flatten, flattenDepth\n * @example\n *\n * flattenDeep([1, [2, [3, [4]], 5]])\n * // => [1, 2, 3, 4, 5]\n */\nfunction flattenDeep(array) {\n  const length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, INFINITY) : [];\n}\n\nexport default flattenDeep;\n```\n\n* flattenDepth.js\n\n```js\n// flattenDepth.js\nimport baseFlatten from './.internal/baseFlatten.js'\n\n/**\n * 递归将数组扁平化至指定深度.\n *\n * @since 4.4.0\n * @category Array\n * @param {Array} array 将扁平化的数组.\n * @param {number} [depth=1] 最大扁平化深度.\n * @returns {Array} 返回扁平化后的数组.\n * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep\n * @example\n *\n * const array = [1, [2, [3, [4]], 5]]\n *\n * flattenDepth(array, 1)\n * // => [1, 2, [3, [4]], 5]\n *\n * flattenDepth(array, 2)\n * // => [1, 2, 3, [4], 5]\n */\nfunction flattenDepth(array, depth) {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : +depth; // 没有depth参数时为1，有的时候转化为正数.\n  return baseFlatten(array, depth);\n}\n\nexport default flattenDepth;\n```\n\n* flatMap.js\n\n```js\nimport baseFlatten from './.internal/baseFlatten.js'\nimport map from './map.js' // 封装map函数\n\n/**\n * 使用 map 重新创建数组，然后使用 baseFlatten 扁平化一级.\n *\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection 将处理的数组.\n * @param {Function} iteratee 数组遍历处理函数\n * @returns {Array} 返回新的扁平化后的数组.\n * @see flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues\n * @example\n *\n * function duplicate(n) {\n *   return [n, n]\n * }\n *\n * flatMap([1, 2], duplicate)\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return baseFlatten(map(collection, iteratee), 1);\n}\n\nexport default flatMap;\n```\n\n* flatMapDeep.js\n\n和 `flattenDeep.js` 类似，只不过扁平化之前和 `flatMap.js` 一样先 `map` 一遍数组，然后进行扁平化处理。\n\n* flatMapDepth.js\n\n和 `flattenDepth.js` 类似，只不过扁平化之前和 `flatMap.js` 一样先 `map` 一遍数组，然后进行扁平化处理。\n\n# 二、数组原生函数\n\n## 1.`Array.prototype.flat`\n\n* 本函数和 `flattenDepth` 类似，只不过是多了一个删除空项的功能，挂载在 `Array` 实例下的函数。\n\n```js\n// 判断是否可展开\nfunction isFlattenable(value) {\n  const spreadableSymbol = Symbol.isConcatSpreadable;\n  return Array.isArray(value) || _.isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n// 判断空\nfunction isEmpty(value) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  return false;\n}\n\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  if (array == null) {\n    return result; // 如果数组为空，则直接返回初始化结果\n  }\n\n  for (const value of array) {\n    if (depth > 0 && predicate(value)) { // 判断深度和是否可展开\n      if (depth > 1) {\n        // 如果深度大于1，继续递归扁平化数组.\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        // 否则 push 进结果集中\n        result.push(...value);\n      }\n    } else if (!isStrict && !isEmpty(value)) {\n      // 如果不检查数组并且不为空，直接不展开放进结果集中\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * 递归将数组扁平化至指定深度.\n *\n * @param {number} [depth=1] 最大扁平化深度.\n * @returns {Array} 返回扁平化后的数组.\n * @example\n *\n * const array = [1, [2, [3, [4]], 5]]\n *\n * array.flat(1)\n * // => [1, 2, [3, [4]], 5]\n *\n * array.flat(2)\n * // => [1, 2, 3, [4], 5]\n */\nArray.prototype.flat = function flattenDepth(depth) {\n  const array = this;\n  const length = array.length;\n  if (!length) {\n    return [];\n  }\n  depth = depth === undefined ? 1 : +depth; // 没有depth参数时为1，有的时候转化为正数.\n  return baseFlatten(array, depth);\n}\n```\n","slug":"js/js_array/1_flatten_extra","updated":"2018-08-14T01:49:19.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46p900090qr4c6sdqmuo","content":"<blockquote>\n<p>专题一已经给大家介绍了数组扁平化，本篇将给大家介绍 <code>lodash</code> 中的 <code>flatten</code> 是如何实现的。</p>\n</blockquote>\n<h1 id=\"一、lodash源码\"><a href=\"#一、lodash源码\" class=\"headerlink\" title=\"一、lodash源码\"></a>一、lodash源码</h1><h2 id=\"1-基础函数\"><a href=\"#1-基础函数\" class=\"headerlink\" title=\"1.基础函数\"></a>1.基础函数</h2><ul>\n<li><code>isFlattenable.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// isFlattenable.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> isArguments <span class=\"keyword\">from</span> <span class=\"string\">'../isArguments.js'</span> <span class=\"comment\">// 检查 value 是否是一个类 arguments 对象，在本篇不予讲解。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6中内置属性，可用于判断数组是否可展开. 具体可见 MDN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> spreadableSymbol = <span class=\"built_in\">Symbol</span>.isConcatSpreadable;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">value[Symbol.isConcatSpreadable] === true时可展开，</span></span><br><span class=\"line\"><span class=\"comment\">可手动设置为false value[Symbol.isConcatSpreadable] = false</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检查值是否可展开.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @private</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; value 要检查的值.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;boolean&#125; 返回布尔值，可展开 -&gt; true, 不可展开 -&gt; false.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFlattenable</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(value) || isArguments(value) ||</span><br><span class=\"line\">    !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> isFlattenable;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>baseFlatten.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// baseFlatten.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> isFlattenable <span class=\"keyword\">from</span> <span class=\"string\">'./isFlattenable.js'</span> <span class=\"comment\">// 是否可以扁平化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * _.flatten 的基本实现与支持限制扁平化。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @private</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 需要扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; depth 扁平化的深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;boolean&#125; [predicate=isFlattenable] 该函数每次迭代判断是否可展开操作.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;boolean&#125; [isStrict] 是否可通过 predicate 检查.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; [result=[]] 初始结果数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的扁平数组.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFlatten</span>(<span class=\"params\">array, depth, predicate, isStrict, result</span>) </span>&#123;</span><br><span class=\"line\">  predicate || (predicate = isFlattenable);</span><br><span class=\"line\">  result || (result = []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// 如果数组为空，则直接返回初始化结果</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span> &amp;&amp; predicate(value)) &#123; <span class=\"comment\">// 判断深度和是否可展开</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果深度大于1，继续递归扁平化数组.</span></span><br><span class=\"line\">        baseFlatten(value, depth - <span class=\"number\">1</span>, predicate, isStrict, result);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则 push 进结果集中</span></span><br><span class=\"line\">        result.push(...value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isStrict) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不检查数组，直接不展开放进结果集中</span></span><br><span class=\"line\">      result[result.length] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> baseFlatten;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>map.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过 iteratee 操作的每个元素，创建一个新数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * iteratee 有三个参数 (value, index, array).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 5.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 要操作的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; iteratee 操作函数.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * function square(n) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   return n * n</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * map([4, 8], square)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [16, 64]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">array, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = iteratee(array[index], index, array);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> map;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-运用函数\"><a href=\"#2-运用函数\" class=\"headerlink\" title=\"2.运用函数\"></a>2.运用函数</h2><p>实际上所有的 <code>flatten</code> 都是依赖上面的基础函数。</p>\n<ul>\n<li><code>flatten.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flatten.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 扁平化一级数组.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 0.1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep, flattenDepth</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flatten([1, [2, [3, [4]], 5]])</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length ? baseFlatten(array, <span class=\"number\">1</span>) : [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flatten;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flattenDeep.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flattenDeep.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 使用一个无限大的数值. */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INFINITY = <span class=\"number\">1</span> / <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归最终扁平为只有一级的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 3.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flatten, flattenDepth</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDeep([1, [2, [3, [4]], 5]])</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDeep</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length ? baseFlatten(array, INFINITY) : [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flattenDeep;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flattenDepth.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flattenDepth.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归将数组扁平化至指定深度.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 4.4.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; [depth=1] 最大扁平化深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * const array = [1, [2, [3, [4]], 5]]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDepth(array, 1)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDepth(array, 2)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, [4], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDepth</span>(<span class=\"params\">array, depth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  depth = depth === <span class=\"literal\">undefined</span> ? <span class=\"number\">1</span> : +depth; <span class=\"comment\">// 没有depth参数时为1，有的时候转化为正数.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(array, depth);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flattenDepth;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatMap.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> map <span class=\"keyword\">from</span> <span class=\"string\">'./map.js'</span> <span class=\"comment\">// 封装map函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 map 重新创建数组，然后使用 baseFlatten 扁平化一级.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 4.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Collection</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array|Object&#125; collection 将处理的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; iteratee 数组遍历处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * function duplicate(n) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   return [n, n]</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flatMap([1, 2], duplicate)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 1, 2, 2]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatMap</span>(<span class=\"params\">collection, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(map(collection, iteratee), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flatMap;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatMapDeep.js</li>\n</ul>\n<p>和 <code>flattenDeep.js</code> 类似，只不过扁平化之前和 <code>flatMap.js</code> 一样先 <code>map</code> 一遍数组，然后进行扁平化处理。</p>\n<ul>\n<li>flatMapDepth.js</li>\n</ul>\n<p>和 <code>flattenDepth.js</code> 类似，只不过扁平化之前和 <code>flatMap.js</code> 一样先 <code>map</code> 一遍数组，然后进行扁平化处理。</p>\n<h1 id=\"二、数组原生函数\"><a href=\"#二、数组原生函数\" class=\"headerlink\" title=\"二、数组原生函数\"></a>二、数组原生函数</h1><h2 id=\"1-Array-prototype-flat\"><a href=\"#1-Array-prototype-flat\" class=\"headerlink\" title=\"1.Array.prototype.flat\"></a>1.<code>Array.prototype.flat</code></h2><ul>\n<li>本函数和 <code>flattenDepth</code> 类似，只不过是多了一个删除空项的功能，挂载在 <code>Array</code> 实例下的函数。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否可展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFlattenable</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> spreadableSymbol = <span class=\"built_in\">Symbol</span>.isConcatSpreadable;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(value) || _.isArguments(value) ||</span><br><span class=\"line\">    !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isEmpty</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"literal\">undefined</span> || value === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFlatten</span>(<span class=\"params\">array, depth, predicate, isStrict, result</span>) </span>&#123;</span><br><span class=\"line\">  predicate || (predicate = isFlattenable);</span><br><span class=\"line\">  result || (result = []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// 如果数组为空，则直接返回初始化结果</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span> &amp;&amp; predicate(value)) &#123; <span class=\"comment\">// 判断深度和是否可展开</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果深度大于1，继续递归扁平化数组.</span></span><br><span class=\"line\">        baseFlatten(value, depth - <span class=\"number\">1</span>, predicate, isStrict, result);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则 push 进结果集中</span></span><br><span class=\"line\">        result.push(...value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isStrict &amp;&amp; !isEmpty(value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不检查数组并且不为空，直接不展开放进结果集中</span></span><br><span class=\"line\">      result[result.length] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归将数组扁平化至指定深度.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; [depth=1] 最大扁平化深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * const array = [1, [2, [3, [4]], 5]]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * array.flat(1)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * array.flat(2)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, [4], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDepth</span>(<span class=\"params\">depth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> array = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  depth = depth === <span class=\"literal\">undefined</span> ? <span class=\"number\">1</span> : +depth; <span class=\"comment\">// 没有depth参数时为1，有的时候转化为正数.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(array, depth);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>专题一已经给大家介绍了数组扁平化，本篇将给大家介绍 <code>lodash</code> 中的 <code>flatten</code> 是如何实现的。</p>\n</blockquote>\n<h1 id=\"一、lodash源码\"><a href=\"#一、lodash源码\" class=\"headerlink\" title=\"一、lodash源码\"></a>一、lodash源码</h1><h2 id=\"1-基础函数\"><a href=\"#1-基础函数\" class=\"headerlink\" title=\"1.基础函数\"></a>1.基础函数</h2><ul>\n<li><code>isFlattenable.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// isFlattenable.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> isArguments <span class=\"keyword\">from</span> <span class=\"string\">'../isArguments.js'</span> <span class=\"comment\">// 检查 value 是否是一个类 arguments 对象，在本篇不予讲解。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6中内置属性，可用于判断数组是否可展开. 具体可见 MDN</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> spreadableSymbol = <span class=\"built_in\">Symbol</span>.isConcatSpreadable;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">value[Symbol.isConcatSpreadable] === true时可展开，</span></span><br><span class=\"line\"><span class=\"comment\">可手动设置为false value[Symbol.isConcatSpreadable] = false</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 检查值是否可展开.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @private</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;*&#125; value 要检查的值.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;boolean&#125; 返回布尔值，可展开 -&gt; true, 不可展开 -&gt; false.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFlattenable</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(value) || isArguments(value) ||</span><br><span class=\"line\">    !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> isFlattenable;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>baseFlatten.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// baseFlatten.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> isFlattenable <span class=\"keyword\">from</span> <span class=\"string\">'./isFlattenable.js'</span> <span class=\"comment\">// 是否可以扁平化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * _.flatten 的基本实现与支持限制扁平化。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @private</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 需要扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; depth 扁平化的深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;boolean&#125; [predicate=isFlattenable] 该函数每次迭代判断是否可展开操作.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;boolean&#125; [isStrict] 是否可通过 predicate 检查.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; [result=[]] 初始结果数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的扁平数组.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFlatten</span>(<span class=\"params\">array, depth, predicate, isStrict, result</span>) </span>&#123;</span><br><span class=\"line\">  predicate || (predicate = isFlattenable);</span><br><span class=\"line\">  result || (result = []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// 如果数组为空，则直接返回初始化结果</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span> &amp;&amp; predicate(value)) &#123; <span class=\"comment\">// 判断深度和是否可展开</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果深度大于1，继续递归扁平化数组.</span></span><br><span class=\"line\">        baseFlatten(value, depth - <span class=\"number\">1</span>, predicate, isStrict, result);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则 push 进结果集中</span></span><br><span class=\"line\">        result.push(...value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isStrict) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不检查数组，直接不展开放进结果集中</span></span><br><span class=\"line\">      result[result.length] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> baseFlatten;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>map.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过 iteratee 操作的每个元素，创建一个新数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * iteratee 有三个参数 (value, index, array).</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 5.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 要操作的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; iteratee 操作函数.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * function square(n) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   return n * n</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * map([4, 8], square)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [16, 64]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">array, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = iteratee(array[index], index, array);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> map;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-运用函数\"><a href=\"#2-运用函数\" class=\"headerlink\" title=\"2.运用函数\"></a>2.运用函数</h2><p>实际上所有的 <code>flatten</code> 都是依赖上面的基础函数。</p>\n<ul>\n<li><code>flatten.js</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flatten.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 扁平化一级数组.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 0.1.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep, flattenDepth</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flatten([1, [2, [3, [4]], 5]])</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length ? baseFlatten(array, <span class=\"number\">1</span>) : [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flatten;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flattenDeep.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flattenDeep.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 使用一个无限大的数值. */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> INFINITY = <span class=\"number\">1</span> / <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归最终扁平为只有一级的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 3.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flatten, flattenDepth</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDeep([1, [2, [3, [4]], 5]])</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, 4, 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDeep</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> length ? baseFlatten(array, INFINITY) : [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flattenDeep;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flattenDepth.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flattenDepth.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归将数组扁平化至指定深度.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 4.4.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; array 将扁平化的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; [depth=1] 最大扁平化深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMap, flatMapDeep, flatMapDepth, flattenDeep</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * const array = [1, [2, [3, [4]], 5]]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDepth(array, 1)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flattenDepth(array, 2)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, [4], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDepth</span>(<span class=\"params\">array, depth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  depth = depth === <span class=\"literal\">undefined</span> ? <span class=\"number\">1</span> : +depth; <span class=\"comment\">// 没有depth参数时为1，有的时候转化为正数.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(array, depth);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flattenDepth;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatMap.js</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> baseFlatten <span class=\"keyword\">from</span> <span class=\"string\">'./.internal/baseFlatten.js'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> map <span class=\"keyword\">from</span> <span class=\"string\">'./map.js'</span> <span class=\"comment\">// 封装map函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用 map 重新创建数组，然后使用 baseFlatten 扁平化一级.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 4.0.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @category Collection</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array|Object&#125; collection 将处理的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; iteratee 数组遍历处理函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回新的扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @see flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, map, mapKeys, mapValues</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * function duplicate(n) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *   return [n, n]</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * flatMap([1, 2], duplicate)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 1, 2, 2]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatMap</span>(<span class=\"params\">collection, iteratee</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(map(collection, iteratee), <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> flatMap;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>flatMapDeep.js</li>\n</ul>\n<p>和 <code>flattenDeep.js</code> 类似，只不过扁平化之前和 <code>flatMap.js</code> 一样先 <code>map</code> 一遍数组，然后进行扁平化处理。</p>\n<ul>\n<li>flatMapDepth.js</li>\n</ul>\n<p>和 <code>flattenDepth.js</code> 类似，只不过扁平化之前和 <code>flatMap.js</code> 一样先 <code>map</code> 一遍数组，然后进行扁平化处理。</p>\n<h1 id=\"二、数组原生函数\"><a href=\"#二、数组原生函数\" class=\"headerlink\" title=\"二、数组原生函数\"></a>二、数组原生函数</h1><h2 id=\"1-Array-prototype-flat\"><a href=\"#1-Array-prototype-flat\" class=\"headerlink\" title=\"1.Array.prototype.flat\"></a>1.<code>Array.prototype.flat</code></h2><ul>\n<li>本函数和 <code>flattenDepth</code> 类似，只不过是多了一个删除空项的功能，挂载在 <code>Array</code> 实例下的函数。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断是否可展开</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFlattenable</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> spreadableSymbol = <span class=\"built_in\">Symbol</span>.isConcatSpreadable;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.isArray(value) || _.isArguments(value) ||</span><br><span class=\"line\">    !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断空</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isEmpty</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value === <span class=\"literal\">undefined</span> || value === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFlatten</span>(<span class=\"params\">array, depth, predicate, isStrict, result</span>) </span>&#123;</span><br><span class=\"line\">  predicate || (predicate = isFlattenable);</span><br><span class=\"line\">  result || (result = []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// 如果数组为空，则直接返回初始化结果</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">0</span> &amp;&amp; predicate(value)) &#123; <span class=\"comment\">// 判断深度和是否可展开</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (depth &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果深度大于1，继续递归扁平化数组.</span></span><br><span class=\"line\">        baseFlatten(value, depth - <span class=\"number\">1</span>, predicate, isStrict, result);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 否则 push 进结果集中</span></span><br><span class=\"line\">        result.push(...value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isStrict &amp;&amp; !isEmpty(value)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果不检查数组并且不为空，直接不展开放进结果集中</span></span><br><span class=\"line\">      result[result.length] = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归将数组扁平化至指定深度.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; [depth=1] 最大扁平化深度.</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns &#123;Array&#125; 返回扁平化后的数组.</span></span><br><span class=\"line\"><span class=\"comment\"> * @example</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * const array = [1, [2, [3, [4]], 5]]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * array.flat(1)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, [3, [4]], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * array.flat(2)</span></span><br><span class=\"line\"><span class=\"comment\"> * // =&gt; [1, 2, 3, [4], 5]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flattenDepth</span>(<span class=\"params\">depth</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> array = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  depth = depth === <span class=\"literal\">undefined</span> ? <span class=\"number\">1</span> : +depth; <span class=\"comment\">// 没有depth参数时为1，有的时候转化为正数.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseFlatten(array, depth);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"JavaScript中的闭包","date":"2018-07-01T08:04:02.000Z","published":1,"_content":"# 作用域\n\n先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。\n在JavaScript中，变量的作用域有全局作用域和局部作用域两种。\n\n## 全局作用域\n\n```js\nvar num1 = 1;\nfunction fun1 (){\n  num2 = 2;\n}\n```\n\n以上三个对象 `num1`, `num2` 和 `fun1` 均是全局作用域，这里要注意的是 **末定义直接赋值的变量自动声明为拥有全局作用域**；\n\n## 局部作用域\n\n```js\nfunction wrap(){\n  var obj = \"我被wrap包裹起来了，wrap外部无法直接访问到我\";\n  function innerFun(){\n      //外部无法访问我\n  }\n}\n```\n\n## 作用域链\n当代码在一个环境中执行时，会创建变量对象的一个作用域链。\n[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。\n作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。\n```js\nfunction foo(){\n    var a = 12;\n    fun(a);\n    function fun(a){\n        var b = 8;\n        console.log(a + b);\n    }\n}  \nfoo();\n```\n再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？\n\n我们以fun为例，当我们调用它时，会创建一个包含 `arguments`，`a`，`b`的 ** 活动对象 **，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即`arguments`(当执行流进入，再创建其他的活动对象)。\n\n在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的`arguments`对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了`arguments中`，但他还是属于。\n\n有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。\n\n下面我们大致说下这段代码的执行流程：\n  1. 在创建`foo`的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性`[[ Scope ]]`当中。\n  2. 执行`foo`函数，创建执行环境与活动对象后，取出函数的内部属性`[[Scope]]`构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。\n  3. 执行过程中遇到了`fun`，从而继续对`fun`使用上一步的操作。\n  4. `fun`执行结束，移出环境栈。`foo`因此也执行完毕，继续移出。\n  5. javscript 监听到`foo`没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。\n\n作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 ** 作用域链 **，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。\n\n# 闭包\n闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n## 闭包的特点：\n  1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。\n  2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。\n其实就是 ** 有权访问另一个函数作用域中的变量的函数 **。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说，** 闭包是连接函数内部和外部的桥梁 **。\n## 闭包的作用\n  1. 访问函数内部的变量。\n  2. 让被引用的变量值始终保持在内存中。\n\n```js\nfunction fn1(){\n    var a = 1;\n    return function(){\n        console.log(++a);\n    }\n\n}\n\nvar fn2 = fn1();\n\nfn2();        //输出2\n\nfn2();        //输出3\n```\n在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。\n\n当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。\n\n基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除\n\n## 闭包的用途\n\n1. 匿名自执行函数\n\n我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，\n比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。\n除了每次使用变量都是用`var`关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，\n比如UI的初始化，那么我们可以使用闭包：\n\n```js\nvar data= {\n  table : [],\n  tree : {}\n};\n\n(function(dm){\n  for(var i = 0; i < dm.table.rows; i++){\n    var row = dm.table.rows[i];\n    for(var j = 0; j < row.cells; i++){\n      drawCell(i, j);\n    }\n  }\n})(data);\n```\n\n我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。\n\n2. 结果缓存\n\n我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，\n\n那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n```js\nvar CachedSearchBox = (function(){\n  var cache = {},\n      count = [];\n  return {\n    attachSearchBox : function(dsid){\n      if(dsid in cache){ //如果结果在缓存中\n        return cache[dsid]; //直接返回缓存中的对象\n      }\n      var fsb = new uikit.webctrl.SearchBox(dsid); //新建\n      cache[dsid] = fsb; //更新缓存\n      if(count.length > 100){ //保正缓存的大小<=100\n        delete cache[count.shift()];\n      }\n      return fsb;\n    },\n\n    clearSearchBox : function(dsid){\n      if(dsid in cache){\n        cache[dsid].clearSelection();\n      }\n    }\n  };\n})();\n\nCachedSearchBox.attachSearchBox(\"input\");\n```\n\n这样我们在第二次调用的时候，就会从缓存中读取到该对象。\n\n3. 封装\n\n```js\nvar person = function(){\n  //变量作用域为函数内部，外部无法访问\n  var name = \"default\";\n\n  return {\n      getName : function(){\n          return name;\n      },\n      setName : function(newName){\n          name = newName;\n      }\n  }\n}();\n\nprint(person.name);//直接访问，结果为undefined\nprint(person.getName());\nperson.setName(\"abruzzi\");\nprint(person.getName());\n\n// 得到结果如下：  \n\n// undefined  \n// default  \n// abruzzi\n```\n\n4. 实现类和继承\n\n```js\nfunction Person(){\n  var name = \"default\";\n\n  return {\n    getName : function(){\n      return name;\n    },\n    setName : function(newName){\n      name = newName;\n    }\n  }\n};\n\nvar p = new Person();\np.setName(\"Tom\");\nalert(p.getName());\n\nvar Jack = function(){};\n//继承自Person\nJack.prototype = new Person();\n//添加私有方法\nJack.prototype.Say = function(){\n  alert(\"Hello,my name is Jack\");\n};\nvar j = new Jack();\nj.setName(\"Jack\");\nj.Say();\nalert(j.getName());\n```\n\n我们定义了`Person`，它就像一个类，我们`new`一个`Person`对象，访问它的方法。\n\n下面我们定义了`Jack`，继承`Person`，并添加自己的方法。","source":"_posts/js/other/closure.md","raw":"---\ntitle: JavaScript中的闭包\ndate: 2018-07-01 16:04:02\ntags: [ 闭包 ]\ncategories: [ JS ]\npublished: true\n---\n# 作用域\n\n先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。\n在JavaScript中，变量的作用域有全局作用域和局部作用域两种。\n\n## 全局作用域\n\n```js\nvar num1 = 1;\nfunction fun1 (){\n  num2 = 2;\n}\n```\n\n以上三个对象 `num1`, `num2` 和 `fun1` 均是全局作用域，这里要注意的是 **末定义直接赋值的变量自动声明为拥有全局作用域**；\n\n## 局部作用域\n\n```js\nfunction wrap(){\n  var obj = \"我被wrap包裹起来了，wrap外部无法直接访问到我\";\n  function innerFun(){\n      //外部无法访问我\n  }\n}\n```\n\n## 作用域链\n当代码在一个环境中执行时，会创建变量对象的一个作用域链。\n[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。\n作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。\n```js\nfunction foo(){\n    var a = 12;\n    fun(a);\n    function fun(a){\n        var b = 8;\n        console.log(a + b);\n    }\n}  \nfoo();\n```\n再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？\n\n我们以fun为例，当我们调用它时，会创建一个包含 `arguments`，`a`，`b`的 ** 活动对象 **，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即`arguments`(当执行流进入，再创建其他的活动对象)。\n\n在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的`arguments`对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了`arguments中`，但他还是属于。\n\n有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。\n\n下面我们大致说下这段代码的执行流程：\n  1. 在创建`foo`的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性`[[ Scope ]]`当中。\n  2. 执行`foo`函数，创建执行环境与活动对象后，取出函数的内部属性`[[Scope]]`构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。\n  3. 执行过程中遇到了`fun`，从而继续对`fun`使用上一步的操作。\n  4. `fun`执行结束，移出环境栈。`foo`因此也执行完毕，继续移出。\n  5. javscript 监听到`foo`没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。\n\n作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 ** 作用域链 **，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。\n\n# 闭包\n闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n## 闭包的特点：\n  1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。\n  2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。\n其实就是 ** 有权访问另一个函数作用域中的变量的函数 **。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说，** 闭包是连接函数内部和外部的桥梁 **。\n## 闭包的作用\n  1. 访问函数内部的变量。\n  2. 让被引用的变量值始终保持在内存中。\n\n```js\nfunction fn1(){\n    var a = 1;\n    return function(){\n        console.log(++a);\n    }\n\n}\n\nvar fn2 = fn1();\n\nfn2();        //输出2\n\nfn2();        //输出3\n```\n在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。\n\n当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。\n\n基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除\n\n## 闭包的用途\n\n1. 匿名自执行函数\n\n我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，\n比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。\n除了每次使用变量都是用`var`关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，\n比如UI的初始化，那么我们可以使用闭包：\n\n```js\nvar data= {\n  table : [],\n  tree : {}\n};\n\n(function(dm){\n  for(var i = 0; i < dm.table.rows; i++){\n    var row = dm.table.rows[i];\n    for(var j = 0; j < row.cells; i++){\n      drawCell(i, j);\n    }\n  }\n})(data);\n```\n\n我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。\n\n2. 结果缓存\n\n我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，\n\n那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。\n\n```js\nvar CachedSearchBox = (function(){\n  var cache = {},\n      count = [];\n  return {\n    attachSearchBox : function(dsid){\n      if(dsid in cache){ //如果结果在缓存中\n        return cache[dsid]; //直接返回缓存中的对象\n      }\n      var fsb = new uikit.webctrl.SearchBox(dsid); //新建\n      cache[dsid] = fsb; //更新缓存\n      if(count.length > 100){ //保正缓存的大小<=100\n        delete cache[count.shift()];\n      }\n      return fsb;\n    },\n\n    clearSearchBox : function(dsid){\n      if(dsid in cache){\n        cache[dsid].clearSelection();\n      }\n    }\n  };\n})();\n\nCachedSearchBox.attachSearchBox(\"input\");\n```\n\n这样我们在第二次调用的时候，就会从缓存中读取到该对象。\n\n3. 封装\n\n```js\nvar person = function(){\n  //变量作用域为函数内部，外部无法访问\n  var name = \"default\";\n\n  return {\n      getName : function(){\n          return name;\n      },\n      setName : function(newName){\n          name = newName;\n      }\n  }\n}();\n\nprint(person.name);//直接访问，结果为undefined\nprint(person.getName());\nperson.setName(\"abruzzi\");\nprint(person.getName());\n\n// 得到结果如下：  \n\n// undefined  \n// default  \n// abruzzi\n```\n\n4. 实现类和继承\n\n```js\nfunction Person(){\n  var name = \"default\";\n\n  return {\n    getName : function(){\n      return name;\n    },\n    setName : function(newName){\n      name = newName;\n    }\n  }\n};\n\nvar p = new Person();\np.setName(\"Tom\");\nalert(p.getName());\n\nvar Jack = function(){};\n//继承自Person\nJack.prototype = new Person();\n//添加私有方法\nJack.prototype.Say = function(){\n  alert(\"Hello,my name is Jack\");\n};\nvar j = new Jack();\nj.setName(\"Jack\");\nj.Say();\nalert(j.getName());\n```\n\n我们定义了`Person`，它就像一个类，我们`new`一个`Person`对象，访问它的方法。\n\n下面我们定义了`Jack`，继承`Person`，并添加自己的方法。","slug":"js/other/closure","updated":"2018-08-01T03:39:51.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46pa000a0qr4lhbcfetl","content":"<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。<br>在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>\n<h2 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  num2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上三个对象 <code>num1</code>, <code>num2</code> 和 <code>fun1</code> 均是全局作用域，这里要注意的是 <strong>末定义直接赋值的变量自动声明为拥有全局作用域</strong>；</p>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrap</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"string\">\"我被wrap包裹起来了，wrap外部无法直接访问到我\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">innerFun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//外部无法访问我</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。<br>作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">    fun(a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> b = <span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure></p>\n<p>再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？</p>\n<p>我们以fun为例，当我们调用它时，会创建一个包含 <code>arguments</code>，<code>a</code>，<code>b</code>的 <strong> 活动对象 </strong>，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即<code>arguments</code>(当执行流进入，再创建其他的活动对象)。</p>\n<p>在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的<code>arguments</code>对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了<code>arguments中</code>，但他还是属于。</p>\n<p>有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。</p>\n<p>下面我们大致说下这段代码的执行流程：</p>\n<ol>\n<li>在创建<code>foo</code>的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性<code>[[ Scope ]]</code>当中。</li>\n<li>执行<code>foo</code>函数，创建执行环境与活动对象后，取出函数的内部属性<code>[[Scope]]</code>构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。</li>\n<li>执行过程中遇到了<code>fun</code>，从而继续对<code>fun</code>使用上一步的操作。</li>\n<li><code>fun</code>执行结束，移出环境栈。<code>foo</code>因此也执行完毕，继续移出。</li>\n<li>javscript 监听到<code>foo</code>没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。</li>\n</ol>\n<p>作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 <strong> 作用域链 </strong>，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。</p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>\n<h2 id=\"闭包的特点：\"><a href=\"#闭包的特点：\" class=\"headerlink\" title=\"闭包的特点：\"></a>闭包的特点：</h2><ol>\n<li>作为一个函数变量的一个引用，当函数返回时，其处于激活状态。</li>\n<li>一个闭包就是当一个函数返回时，一个没有释放资源的栈区。<br>其实就是 <strong> 有权访问另一个函数作用域中的变量的函数 </strong>。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说，<strong> 闭包是连接函数内部和外部的桥梁 </strong>。<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2></li>\n<li>访问函数内部的变量。</li>\n<li>让被引用的变量值始终保持在内存中。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(++a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1();</span><br><span class=\"line\"></span><br><span class=\"line\">fn2();        <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2();        <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>\n<p>在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。</p>\n<p>当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。</p>\n<p>基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><ol>\n<li>匿名自执行函数</li>\n</ol>\n<p>我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，<br>比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。<br>除了每次使用变量都是用<code>var</code>关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，<br>比如UI的初始化，那么我们可以使用闭包：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data= &#123;</span><br><span class=\"line\">  table : [],</span><br><span class=\"line\">  tree : &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dm</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; dm.table.rows; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> row = dm.table.rows[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; row.cells; i++)&#123;</span><br><span class=\"line\">      drawCell(i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(data);</span><br></pre></td></tr></table></figure>\n<p>我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。</p>\n<ol start=\"2\">\n<li>结果缓存</li>\n</ol>\n<p>我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，</p>\n<p>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CachedSearchBox = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cache = &#123;&#125;,</span><br><span class=\"line\">      count = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    attachSearchBox : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dsid</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dsid <span class=\"keyword\">in</span> cache)&#123; <span class=\"comment\">//如果结果在缓存中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[dsid]; <span class=\"comment\">//直接返回缓存中的对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> fsb = <span class=\"keyword\">new</span> uikit.webctrl.SearchBox(dsid); <span class=\"comment\">//新建</span></span><br><span class=\"line\">      cache[dsid] = fsb; <span class=\"comment\">//更新缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(count.length &gt; <span class=\"number\">100</span>)&#123; <span class=\"comment\">//保正缓存的大小&lt;=100</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> cache[count.shift()];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fsb;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    clearSearchBox : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dsid</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dsid <span class=\"keyword\">in</span> cache)&#123;</span><br><span class=\"line\">        cache[dsid].clearSelection();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">CachedSearchBox.attachSearchBox(<span class=\"string\">\"input\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这样我们在第二次调用的时候，就会从缓存中读取到该对象。</p>\n<ol start=\"3\">\n<li>封装</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//变量作用域为函数内部，外部无法访问</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      getName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      setName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>)</span>&#123;</span><br><span class=\"line\">          name = newName;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">print(person.name);<span class=\"comment\">//直接访问，结果为undefined</span></span><br><span class=\"line\">print(person.getName());</span><br><span class=\"line\">person.setName(<span class=\"string\">\"abruzzi\"</span>);</span><br><span class=\"line\">print(person.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 得到结果如下：  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// default  </span></span><br><span class=\"line\"><span class=\"comment\">// abruzzi</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>实现类和继承</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>)</span>&#123;</span><br><span class=\"line\">      name = newName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.setName(<span class=\"string\">\"Tom\"</span>);</span><br><span class=\"line\">alert(p.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Jack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//继承自Person</span></span><br><span class=\"line\">Jack.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"comment\">//添加私有方法</span></span><br><span class=\"line\">Jack.prototype.Say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"Hello,my name is Jack\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> j = <span class=\"keyword\">new</span> Jack();</span><br><span class=\"line\">j.setName(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">j.Say();</span><br><span class=\"line\">alert(j.getName());</span><br></pre></td></tr></table></figure>\n<p>我们定义了<code>Person</code>，它就像一个类，我们<code>new</code>一个<code>Person</code>对象，访问它的方法。</p>\n<p>下面我们定义了<code>Jack</code>，继承<code>Person</code>，并添加自己的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>先来说下什么是作用域，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。他减少了名称冲突，并且提供了自动内存管理。<br>在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p>\n<h2 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  num2 = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上三个对象 <code>num1</code>, <code>num2</code> 和 <code>fun1</code> 均是全局作用域，这里要注意的是 <strong>末定义直接赋值的变量自动声明为拥有全局作用域</strong>；</p>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrap</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"string\">\"我被wrap包裹起来了，wrap外部无法直接访问到我\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">innerFun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//外部无法访问我</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>[{当前环境的变量对象}，{外层变量对象}，{外层的外层的变量对象}, {window全局变量对象}] 每个数组单元就是作用域链的一块，这个块就是我们的变量对象。<br>作用于链的前端，始终都是当前执行的代码所在环境的变量对象。全局执行环境的变量对象也始终都是链的最后一个对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">12</span>;</span><br><span class=\"line\">    fun(a);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> b = <span class=\"number\">8</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure></p>\n<p>再来看上面这个简单的例子，我们可以先思考一下，每个执行环境下的变量对象都是什么？ 这两个函数它们的变量对象分别都是什么？</p>\n<p>我们以fun为例，当我们调用它时，会创建一个包含 <code>arguments</code>，<code>a</code>，<code>b</code>的 <strong> 活动对象 </strong>，对于函数而言，在执行的最开始阶段它的活动对象里只包含一个变量，即<code>arguments</code>(当执行流进入，再创建其他的活动对象)。</p>\n<p>在活动对象中，它依然表示当前参数集合。对于函数的活动对象，我们可以想象成两部分，一个是固定的<code>arguments</code>对象，另一部分是函数中的局部变量。而在此例中，a和b都被算入是局部变量中，即便a已经包含在了<code>arguments中</code>，但他还是属于。</p>\n<p>有没有发现在环境栈中，所有的执行环境都可以组成相对应的作用域链。我们可以在环境栈中非常直观的拼接成一个相对作用域链。</p>\n<p>下面我们大致说下这段代码的执行流程：</p>\n<ol>\n<li>在创建<code>foo</code>的时候，作用域链已经预先包含了一个全局对象，并保存在内部属性<code>[[ Scope ]]</code>当中。</li>\n<li>执行<code>foo</code>函数，创建执行环境与活动对象后，取出函数的内部属性<code>[[Scope]]</code>构建当前环境的作用域链(取出后，只有全局变量对象，然后此时追加了一个它自己的活动对象)。</li>\n<li>执行过程中遇到了<code>fun</code>，从而继续对<code>fun</code>使用上一步的操作。</li>\n<li><code>fun</code>执行结束，移出环境栈。<code>foo</code>因此也执行完毕，继续移出。</li>\n<li>javscript 监听到<code>foo</code>没有被任何变量所引用，开始实施垃圾回收机制，清空占用内存。</li>\n</ol>\n<p>作用域链其实就是引用了当前执行环境的变量对象的指针列表，它只是引用，但不是包含，因为它的形状像链条，它的执行过程也非常符合，所以我们都称之为 <strong> 作用域链 </strong>，而当我们弄懂了这其中的奥秘，就可以抛开这种形式上的束缚，从原理上出发。</p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>\n<h2 id=\"闭包的特点：\"><a href=\"#闭包的特点：\" class=\"headerlink\" title=\"闭包的特点：\"></a>闭包的特点：</h2><ol>\n<li>作为一个函数变量的一个引用，当函数返回时，其处于激活状态。</li>\n<li>一个闭包就是当一个函数返回时，一个没有释放资源的栈区。<br>其实就是 <strong> 有权访问另一个函数作用域中的变量的函数 </strong>。简单说就是，假设函数a是定义在函数b中的函数，那么函数a就是一个闭包。正常情况下，在函数的外部访问不到函数内部的变量，但有了闭包就可以间接的实现访问内部变量的需要。也就是说，<strong> 闭包是连接函数内部和外部的桥梁 </strong>。<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2></li>\n<li>访问函数内部的变量。</li>\n<li>让被引用的变量值始终保持在内存中。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(++a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1();</span><br><span class=\"line\"></span><br><span class=\"line\">fn2();        <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2();        <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>\n<p>在这段代码中，fn1中的闭包函数被当作结果返回，在闭包中的引用的变量a因为被引用而没有被清除，一直保存在内存当中，所以执行fn2的时候会输出不断增加的结果：2和3。</p>\n<p>当闭包中引用了函数中的变量时，那么，这个变量就会保存在内存中。也就是上面提到的闭包的第二个作用。之所以为这样，是因为JavaScript的回收机制。</p>\n<p>基本所有浏览器都是使用“标记清除”的方式回收内存。也就是说，当变量进入执行环境的时候（在函数中声明一个变量），就给变量添加标记，而当函数执行完的，变量不再被引用的时候，再添加删除的标记，垃圾收集器就会自动清楚这个变量占有的内存。但在闭包中引用了函数中的变量，而闭包又被当作结果返回时，闭包中的因为被引用就不会被清除</p>\n<h2 id=\"闭包的用途\"><a href=\"#闭包的用途\" class=\"headerlink\" title=\"闭包的用途\"></a>闭包的用途</h2><ol>\n<li>匿名自执行函数</li>\n</ol>\n<p>我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，<br>比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。<br>除了每次使用变量都是用<code>var</code>关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，<br>比如UI的初始化，那么我们可以使用闭包：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data= &#123;</span><br><span class=\"line\">  table : [],</span><br><span class=\"line\">  tree : &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dm</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; dm.table.rows; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> row = dm.table.rows[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; row.cells; i++)&#123;</span><br><span class=\"line\">      drawCell(i, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(data);</span><br></pre></td></tr></table></figure>\n<p>我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。</p>\n<ol start=\"2\">\n<li>结果缓存</li>\n</ol>\n<p>我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，</p>\n<p>那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CachedSearchBox = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cache = &#123;&#125;,</span><br><span class=\"line\">      count = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    attachSearchBox : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dsid</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dsid <span class=\"keyword\">in</span> cache)&#123; <span class=\"comment\">//如果结果在缓存中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[dsid]; <span class=\"comment\">//直接返回缓存中的对象</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> fsb = <span class=\"keyword\">new</span> uikit.webctrl.SearchBox(dsid); <span class=\"comment\">//新建</span></span><br><span class=\"line\">      cache[dsid] = fsb; <span class=\"comment\">//更新缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(count.length &gt; <span class=\"number\">100</span>)&#123; <span class=\"comment\">//保正缓存的大小&lt;=100</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> cache[count.shift()];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fsb;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    clearSearchBox : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dsid</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dsid <span class=\"keyword\">in</span> cache)&#123;</span><br><span class=\"line\">        cache[dsid].clearSelection();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">CachedSearchBox.attachSearchBox(<span class=\"string\">\"input\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这样我们在第二次调用的时候，就会从缓存中读取到该对象。</p>\n<ol start=\"3\">\n<li>封装</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//变量作用域为函数内部，外部无法访问</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      getName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      setName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>)</span>&#123;</span><br><span class=\"line\">          name = newName;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">print(person.name);<span class=\"comment\">//直接访问，结果为undefined</span></span><br><span class=\"line\">print(person.getName());</span><br><span class=\"line\">person.setName(<span class=\"string\">\"abruzzi\"</span>);</span><br><span class=\"line\">print(person.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 得到结果如下：  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined  </span></span><br><span class=\"line\"><span class=\"comment\">// default  </span></span><br><span class=\"line\"><span class=\"comment\">// abruzzi</span></span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>实现类和继承</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"default\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    setName : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>)</span>&#123;</span><br><span class=\"line\">      name = newName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">p.setName(<span class=\"string\">\"Tom\"</span>);</span><br><span class=\"line\">alert(p.getName());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Jack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">//继承自Person</span></span><br><span class=\"line\">Jack.prototype = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\"><span class=\"comment\">//添加私有方法</span></span><br><span class=\"line\">Jack.prototype.Say = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">\"Hello,my name is Jack\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> j = <span class=\"keyword\">new</span> Jack();</span><br><span class=\"line\">j.setName(<span class=\"string\">\"Jack\"</span>);</span><br><span class=\"line\">j.Say();</span><br><span class=\"line\">alert(j.getName());</span><br></pre></td></tr></table></figure>\n<p>我们定义了<code>Person</code>，它就像一个类，我们<code>new</code>一个<code>Person</code>对象，访问它的方法。</p>\n<p>下面我们定义了<code>Jack</code>，继承<code>Person</code>，并添加自己的方法。</p>\n"},{"title":"JavaScript面向对象程序设计","date":"2018-07-02T15:01:02.000Z","published":1,"_content":"**JavaScript面向对象程序设计**\n本文会碰到的知识点：\n原型、原型链、函数对象、普通对象、继承\n\n读完本文，可以学到\n\n* 面向对象的基本概念\n* JavaScript对象属性\n* 理解JavaScript中的函数对象与普通对象\n* 理解`prototype`和`proto`\n* 理解原型和原型链\n* 详解原型链相关的Object方法\n* 了解如何用ES5模拟类，以及各种方式的优缺点\n* 了解如何用ES6实现面向对象\n\n# 一、面向对象的基本概念\n\n面向对象也即是OOP，Object Oriented Programming，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例，但是JavaScript中没有类的概念，而是直接使用对象来实现编程。\n特性：\n\n* 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。\n\n由于JavaScript没有`public`、`private`、`protected`这些关键字，但是可以利用变量的作用域来模拟public和private封装特性\n\n```js\nvar insObject = (function() {\n  var _name = 'hello'; // private\n  return {\n    getName: function() { // public\n      return _name;\n    }\n  }\n})();\n\ninsObject._name; // undefined\ninsObject.getName(); // hello\n```\n\n这里只是实现了一个简单的版本，private比较好的实现方式可以参考深入理解`ES6 145页`,protected可以利用ES6的Symbol关键字来实现，这里不展开，有兴趣可以讨论\n\n**继承**：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写，后面的章节详细描述\n\n# 二、JavaScript对象属性\n\n想弄懂面向对象，是不是先看看对象是啥呢？\n我们先看一个题目:\n\n```js\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n解释：\n在第一行中，`{}`出现在`+`操作符的表达式中，因此被翻译为一个实际的值（一个空`object`）。而`[]`被强制转换为\"\",因此`{}`也会被强制转换为一个`string:\"[object Object]\"`。 \n但在第二行中，`{}`被翻译为一个独立的`{}`空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，`+ []`是一个将`[]`明确强制转换 为`number`的表达式，而它的值是`0`。\n\n## 2.1 属性\n\n*对象的属性*\n\n* `Object.prototype` Object 的原型对象，不是每个对象都有`prototype`属性\n* `Object.prototype.proto` 不是标准方法，不鼓励使用，每个对象都有`proto`属性，但是由于浏览器实现方式的不同，`proto`属性在chrome、firefox中实现了，在IE中并不支持，替代的方法是`Object.getPrototypeOf()`\n* `Object.prototype.constructor`：用于创建一个对象的原型，创建对象的构造函数\n\n可能大家会有一个疑问，为什么上面那些属性要加上`prototype`\n在chrome中打印一下`var a = { test: 'test' }`\n\n*属性描述符*\n数据属性：\n\n| 特性名称 | 描述 | 默认值 |\n| - | - | - |\n| value | 属性的值 | undfined |\n| writable | 是否可以修改属性的值，true表示可以，false表示不可以 | true |\n| enumerable | 属性值是否可枚举，true表示可枚举for-in, false表示不可枚举 | true |\n| configurable | 属性的特性是否可配置，表示能否通过delete删除属性后重新定义属性 | true |\n例子:\n![img](//sml-myoss.oss-cn-beijing.aliyuncs.com/blog/word_img/20180702231814.png)\n\n访问器属性：\n\n| 特性名称 | 描述 | 默认值 |\n| - | - | - |\n| set | 设置属性时调用的函数 | undefined |\n| get | 写入属性时调用的函数 | undefined |\n| configurable | 表示能否通过delete删除属性后重新定义属性 | true |\n| enumerable | 表示能否通过for-in循环返回属性 | true |\n\n访问器属性不能直接定义，一般是通过`Object.defineProperty()`方法来定义，但是这个方法只支持IE9+， 以前一般用两个非标准方法来实现`__defineGetter__()`和֖`__defineSetter__() `\n\n例子：\n\n```js\nvar book = { _year: 2004, edition: 1 };\n\nObject.defineProperty(book, \"year\", {\n  get: function(){\n    return this._year;\n  },\n  set: function(newValue){\n    if (newValue > 2004){\n      this._year = newValue;\n      this.edition += newValue - 2004;\n    }\n  }\n});\n\nbook.year = 2005; \nalert(book.edition);\n```\n\n## 2.2 方法\n\n* `Object.prototype.toString()` 返回对象的字符串表示\n* `Object.prototype.hasOwnProperty()` 返回一个布尔值，表示某个对象是否含有指定的属性，而且此属性非原型链继承，也就是说不会检查原型链上的属性\n* `Object.prototype.isPrototypeOf()` 返回一个布尔值，表示指定的对象是否在本对象的原型链中\n* `Object.prototype.propertyIsEnumerable()` 判断指定属性是否可枚举\n* `Object.prototype.watch()` 给对象的某个属性增加监听\n* `Object.prototype.unwatch()` 移除对象某个属性的监听\n* `Object.prototype.valueOf()` 返回指定对象的原始值\n* 获取和设置属性\n  * `Object.defineProperty` 定义单个属性\n  * `Object.defineProperties` 定义多个属性\n  * `Object.getOwnPropertyDescriptor` 获取属性\n* `Object.assign()` 拷贝可枚举属性 （ES6新增）\n* `Object.create()` 创建对象\n* `Object.entries()` 返回一个包含由给定对象所有可枚举属性的属性名和属性值组成的 [属性名，属性值] 键值对的数组，数组中键值对的排列顺序和使用for…in循环遍历该对象时返回的顺序一致\n* `Object.freeze()` 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象\n* `Object.getOwnPropertyNames()` 返回指定对象的属性名组成的数组\n* `Object.getPrototypeOf` 返回该对象的原型\n* `Object.is(value1, value2)` 判断两个值是否是同一个值 (ES6 新增)\n* `Object.keys()` 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致\n* `Object.setPrototypeOf(obj, prototype)` 将一个指定的对象的原型设置为另一个对象或者null\n* `Object.values` 返回一个包含指定对象所有的可枚举属性值的数组，数组中的值顺序和使用for…in循环遍历的顺序一样\n\n## 2.3 应用\n\n如何检测某个属性是否在对象中？\n\n* in运算符，判断对象是否包含某个属性，会从对象的实例属性、继承属性里进行检测\n\n```js\nfunction Dogs(name) {\n  this.name = name\n}\n\nfunction BigDogs(size) {\n  this.size = size;\n}\n\nBigDogs.prototype = new Dogs();\n\nvar a = new BigDogs('big');\n\n'size' in a;\n'name' in a;\n'age' in a;\n```\n\n* Object.hasOwnProperty()，判断一个对象是否有指定名称的属性，不会检查继承属性\n\n```js\na.hasOwnProperty('size');\na.hasOwnProperty('name');\na.hasOwnProperty('age');\n```\n\n* `Object.propertyIsEnumerable()`，判断指定名称的属性是否为实例属性并且是可枚举的\n\n```js\n// es6\nvar a = Object.create({}, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  }\n});\n\n// es5\nvar b = {};\nObject.defineProperties(b, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  } \n});\n\na.propertyIsEnumerable('name');\na.propertyIsEnumerable('age');\n```\n\n* 如何枚举对象的属性，并保证不同了浏览器中的行为是一致的？\n\n`for/in` 语句，可以遍历可枚举的实例属性和继承属性\n\n```js\nvar a = {\n  supername: 'super hello',\n  superage: 'super name',\n}\nvar b = {};\nObject.defineProperties(b, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  }\n});\n\nObject.setPrototypeOf(b, a); // 设置b的原型是a 等效的是b.__proto__ = a\n\nfor(pro in b) {\n  console.log(pro); // name, supername, superage\n}\n```\n\n* `Object.keys()`， 返回一个数组，内容是对象可枚举的实例属性名称\n\n```js\nvar propertyArray = Object.keys(b); // name\n```\n\n* `Object.getOwnPropertyNames()`，返回一个数组，内容是对象所有实例属性，包括可枚举和不可枚举\n\n```js\nvar propertyArray = Object.getOwnPropertyNames(b); // name, age\n```\n\n* 如何判断两个对象是否相等？\n\n我只想说，这个问题说简单很简单，说复杂也挺复杂的[传送门](https://stackoverflow.com/questions/1068834/object-comparison-in-javascript)\n我们看个简单版的\n\n```js\nfunction isEquivalent(a, b) {\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length != bProps.length){\n    return false;\n  }\n\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Outputs: true\nconsole.log(isEquivalent({a:1},{a:1}));\n```\n\n上面这个函数还有啥问题呢\n\n* 没有对传入参数进行校验，例如判断是否是NaN，或者是其他内置属性\n* 没有判断传入对象的construct和prototype\n* 时间算法复杂度是O(n2)\n\n有同学可能会有疑问，能不能用`Object.is`，答案是否定的，`Object.is`简单来说就是在`===`的基础上特别处理了`NaN`，`+0`，`-0`，保证了`-0`和`+0`不相同，`Object.is(NaN, NaN)`返回`true`。\n\n* 对象的深拷贝和浅拷贝\n\n其实如果大家理解了上面的那些方法，是很容易写出深拷贝和浅拷贝的代码的，我们先看一下这两者的却别。\n浅拷贝仅仅是复制引用，拷贝后`a === b`， 注意`Object.assign`方法实现的是浅复制（此处有深刻教训！！！）\n深拷贝这是创建了一个新的对象，然后把旧的对象中的属性和方法拷贝到新的对象中，拷贝后 `a !== b`\n深拷贝的实现由很多例子，例如`jQuery`的`extend`和`lodash中的cloneDeep`, clone。jQuery可以使用`$.extend(true, {}, ...)`来实现深拷贝, 但是jQuery无法复制JSON对象之外的对象，例如ES6引入的`Map`、`Set`等。而lodash加入的大量的代码来实现ES6新引入的标准对象\n\n# 三、对象分为函数对象和普通对象\n\n** 什么是函数对象和普通对象？**\n`Object`、`Function`、`Array`、`Date`等js的内置对象都是函数对象\n\n```js\nfunction a1 () {}\nconst a2 = function () {}\nconst a3 = new Function();\n\nconst b1 = {};\nconst b2 = new Object();\n\nconst c1 = [];\nconst c2 = new Array();\n\nconst d1 = new a1();\nconst d2 = new b1(); // ????\nconst d3 = new c1(); // ????\n\ntypeof a1;\ntypeof a2;\ntypeof a3;\n\ntypeof b1;\ntypeof b2;\n\ntypeof c1;\ntypeof c2;\n\ntypeof d1;\n```\n\n上面两行报错的原因，是因为构造函数只能由函数来充当，而b1和c1不是Function的实例，所以不能充当构造器\n** 但是只有Function的实例都是函数对象、其他的实例都是普通对象 **\n我们延伸一下，在看个例子\n\n```js\nconst e1 = function *(){};\nconst e2 = new e1();\n// Uncaught TypeError: e1 is not a constructor\nconsole.log(e1.constructor) // 是有值的。。。\n// 规范里面就不能new\nconst e2 = e1();\n```\n\n`GeneratorFunction`是一个特殊的函数对象 \n`e1.__proto__.__proto__ === Function.prototype`\n\n`e1`的原型实际上是一个生成器函数`GeneratorFunction`，也就是说 \n`e1.__proto__ === GeneratorFunction.prototype`\n\n这行代码有问题么，啊哈哈哈，`GeneratorFunction`这个关键字主流的JavaScript还木有暴露出来，所以这个大家理解就好啦\n\n虽然不能直接`new e1`\n但是可以`new e1.constructor();`哈哈哈哈\n\n# 四、理解prototype和proto\n\n| 对象类型 | prototype | proto |\n| - | - |\n| 函数对象 | Yes | Yes |\n| 普通对象 | No | Yes |\n\n* 只有函数对象具有`prototype`这个属性\n* `prototype`和`__proto__`都是js在定义一个对象时的预定义属性\n* `prototype`是被实例的`__proto__`指向\n* `__proto__`指向构造函数的`prototype`\n\n```js\nconst a = function(){}\nconst b = {}\n\ntypeof a // function\ntypeof b // object\n\ntypeof a.prototype // object\ntypeof a.__proto__ // function\n\ntypeof b.prototype // undefined\ntypeof b.__proto__ // object\n\na.__proto__ === Function.prototype\nb.__proto__ === Object.prototype\n```\n\n理解了`prototype`和`__proto__`之后，我们来看看之前一直说的为什么JavaScript里面都是对象\n\n```js\nconst a = {}\nconst b = function () {}\nconst c = []\nconst d = new Date()\n\na.__proto__\na.__proto__ === Object.prototype\n\nb.__proto__\nb.__proto__ === Function.prototype\n\nc.__proto__\nc.__proto__ === Array.prototype\n\nd.__proto__\nd.__proto__ === Date.prototype\n\nObject.prototype.__proto__ //null\n\nFunction.prototype.__proto__ === Object.prototype\n\nArray.prototype.__proto__ === Object.prototype\n\nDate.prototype.__proto__ === Object.prototype\n```\n\n延伸一个问题：如何判断一个变量是否是数组？\n\n* typeof\n\n我们上面已经解释了，这些都是普通对象，普通对象是没有`prototype`的，他们`typeof`的值都是`object`\n\n```js\ntypeof []\ntypeof {}\n```\n\n从原型来看, 原理就是看Array是否在a的原型链中\na的原型链是 Array->Object\n\n```js\nconst a = [];\nArray.prototype.isPrototypeOf(obj);\n```\n\n* instanceof\n\n```js\nconst a = [];\na instanceof Array\n```\n\n从构造函数入手，但是这个方法和上面的方法都有一问题，不同的框架中创建的数组不会相互共享其`prototype`属性\n根据对象的class属性，跨原型调用`tostring`方法\n\n```js\nconst a = [];\nObject.prototype.toString.call(a);\n// [Object Array]\n```\n\nES5 中所有内置对象的[[Class]]属性的值是由规范定义的，但是 ES6 中已经没有了[[Class]]属性，取代它的是[[NativeBrand]]属性，这个大家有兴趣可以自行去查看规范 \n原理：\n\n1. 如果`this`的值为`undefined`,则返回`'[object Undefined]'`. \n2. 如果`this`的值为`null`,则返回`[object Null]`. \n3. 让`O`成为调用`ToObject(this)`的结果. \n4. 让`class`成为`O`的内部属性`[[Class]]`的值. \n5. 返回三个字符串`'[object '`, `'class'`, 以及 `']'`连接后的新字符串.\n\n问题？这个一定是正确的么？不正确为啥？ \n提示ES6的`Symbol`属性\n`Array.isArray()` \n部分浏览器中不兼容\n\n# 五、理解原型与原型链\n\n其实上一节中的`prototype`和`proto`就是为了构建原型链而存在的，之前也或多或少的说到了原型链这个概念。\n\n看下面的代码:\n\n```js\nconst Dogs = function(name) {\n    this.name = name;\n}\n\nDogs.prototype.getName = function() {\n    return this.name\n}\n\nconst sijing = new Dogs('sijing');\nconsole.log(sijing);\nconsole.log(sijing.getName());\n```\n\n这段代码的执行过程\n\n1. 首先创建了一个构造函数`Dogs`，传入一个参数`name`，`Dogs.prototype`也会自动创建\n2. 给对象`dogs`增加了一个方法 \n3. 通过构造函数`Dogs`实例化了一个对象`sijing`\n4. 输出`sijing`的值,可以看到`sijing`有两个值`name`和`proto`,其中`proto`指向`Dogs.prototype`\n5. 执行`getName`方法时，在`sijing`中找不到这个方法，就会继续向着原型链继续往上找，也就是通过`proto`，然后就找到了`getName`方法。\n\n这个过程实际上就是原型继承，实际上JavaScript的原型继承就是利用了`proto`并借助`prototype`来实现的。\n\n```js\nsijing.__proto__ === Function.prototype\n\nDogs.prototype // 指向什么\nDogs.prototype.__proto__ // 指向什么\nDogs.prototype.__proto__.__proto__ // 指向什么\n```\n\n上面例子中`getName`最终是查找到了，那么如果在原型链中一直没查找到，会怎么样？ \n例如`console.log(sijing.age)`\n\n```js\nsijing // 是一个对象可以继续\nsijing.age // 不存在，继续\nsijing.__proto__ // 是一个对象可以继续\nsijing.__proto__.age // 不存在，继续\nsijing.__proto__.__proto__ // 是个对象可以继续\nsijing.__proto__.__proto__.age // 不存在，继续\nsijing.__proto__.__proto__.__proto__ null，// 不是对象，到头啦\n```\n\n**原型链** 的概念其实不重要，重要的是要理解，简单来说，原型链就是利用原型让一个引用类型继承另一个应用类型的属性和方法。\n\n还有三点需要注意的:\n\n* 任何内置函数对象（类）本身的 `_proto_`都指向`Function`的原型对象；\n* 除了`Object`的原型对象的`_proto_`指向`null`，其他所有内置函数对象的原型对象的`_proto_`都指向`object`。\n* 所有构造函数的的`prototype`方法的`proto`都指向`Object.prototype`（除了….`Object.prototype`自身）\n\n如果理解了上面这些内容，大家可以自行描述一下，构造函数、原型和实例之间的关系.\n\n* 构造函数首字母必须大写，用来区分普通函数，内部使用`this`指针，指向要生成的实例对象，通过`new`来生成实例对象。 \n* 实例就是通过`new`一个构造函数产生的对象，它有一个属性`[[prototype]]`指向原型 \n* 原型中有一个属性`[[constructor]]`，指向构造函数\n\n# 六、与原型链相关的方法\n\n## 6.1 hasOwnProperty\n\n`Object.hasOwnProperty()`返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有`in`操作符，`in`操作符只要属性存在，不管实在实例中还是原型中，就会返回`true`。同时使用`in`和`hasOwnProperty`就可以判断属性是在原型中还是在实例中\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(14);\nsijing.hasOwnProperty('age');\n```\n\n## 6.2 isPrototypeOf\n\n`Object.prototype.isPrototypeOf()`返回一个布尔值，表示指定的对象是否在本对象的原型链中\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(11);\nObject.prototype.isPrototypeOf(Dogs);\nDogs.prototype.isPrototypeOf(sijing);\n```\n\n## 6.3 getPrototypeOf\n\n`Object.getPrototypeOf`返回该对象的原型\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(11);\nsijing.__proto__ === Object.getPrototypeOf(sijing) \n```\n\n# 七、ES5 对象继承\n\n## 7.1 原型继承\n\n原型继承就是利用** 原型链 **来实现继承\n\n```js\nfunction SuperType() {\n  this.supername = 'super';\n}\n\nSuperType.prototype.getSuperName= function(){\n  return this.supername;\n}\n\nfunction SubType () {\n  this.subname='subname';\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubName = function (){\n  return this.subname;\n}\n\nvar instance1 = new SubType();\nconsole.log(instance1.getSubName());\nconsole.log(instance1.getSuperName());\n```\n\n需要注意的地方： \n实现原型继承的时候不要使用对象字面量创建原型方法，因为这样做，会重写原型链。\n\n```js\nfunction SuperType() {\n  this.supername = 'super';\n}\n\nSuperType.prototype.getSuperName= function(){\n  return this.supername;\n}\n\nfunction SubType () {\n  this.subname='subname';\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype =  {\n  getSubName: function (){\n    return this.subname;\n  }\n}\n\nvar instance1 = new SubType();\nconsole.log(instance1.getSubName());\nconsole.log(instance1.getSuperName()); // error\n```\n\n上面使用`SubType.prototype = {...}`之后，`SubType`的原型就是`Object`了，而不是`SuperType`了。\n\n优点：原型定义的属性和方法可以复用\n缺点：\n\n1. 引用类型的原型属性会被所有实例共享 \n2. 创建子对象时，不能向父对象的构造函数中传递参数\n\n## 7.2 构造函数继承\n\n```js\nvar a = {\n  name: 'a',\n};\n\nvar name = 'window';\n\nvar getName = function(){\n  console.log(this.name);\n}\n\ngetName() // window\ngetName.call(a) // a\n```\n\n执行`getName()`时，函数体的`this`指向`window`，而执行`getName.call(a)`时，函数体的`this`指向的是`a`对象，所以就可以理解啦。接下来我们看如何实现构造函数继承\n\n```js\nfunction SuperType () {\n  this.colors = ['red', 'green'];\n}\n\nfunction SubType () {\n  // 继承SuperType\n  SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.colors.push('blue'); \nconsole.log(instance1.colors); // red, green, blue\n\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // red, green\n```\n\n`SuperType.call(this)`这一行代码，实际上意思是在`SubType`的实例初始化过程中，调用了`SuperType`的构造函数，因此`SubType`的每个实例都有`colors`这个属性\n\n优点：子对象可以传递参数给父对象。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\nfunction SubType(name, age) {\n  name = name || 'hello';\n  SuperType.call(this, name);\n  this.age = age;\n}\n\nvar instance1 = new SubType('scofield', 28);\nconsole.log(instance1.name); //\nconsole.log(instance1.age); //\n```\n\n需要注意的地方是在调用父对象的构造函数之后，再给子类型中的定义属性，否则会被重写。\n\n缺点：方法都需要在构造函数中定义，难以做到函数的复用，而且在父对象的原型上定义的方法，对于子类型是不可见的。 ??? 为什么不可见\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\n\nSuperType.prototype.getName = function() {\n  return this.name;\n}\n\nSuperType.prototype.prefix = function() {\n  return 'prefix';\n}\n\nfunction SubType(name) {\n  SuperType.call(this, name);\n}\n\nvar instance1 = new SubType('scofield');\nconsole.log(instance1.name);\nconsole.log(instance1.prefix);\nconsole.log(instance1.getName()); // Uncaught TypeError: instance1.getName is not a function\n```\n\n## 7.3 组合式继承\n\n**组合式继承** 顾名思义，就是组合两种模式实现JavaScript的继承，借助 **原型链** 和 **构造函数** 来实现。这样子在原型上定义方法实现了函数的复用，而且能够保证每个实例都有自己的属性。\n\n```js\nfunction SuperType (name) {\n  this.name = name;\n  this.con = [];\n}\n\nSuperType.prototype.getName = function() {\n  return this.name;\n}\n\nfunction SubType (name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.getAge = function() {\n  return this.age;\n};\n\nvar instance1 = new SubType('li', 18);\ninstance1.con.push('test1');\nconsole.log(instance1.con); // test1\nconsole.log(instance1.getAge()); // 18\nconsole.log(instance1.getName()); // li\n\nvar instance2 = new SubType('hang', 18);\nconsole.log(instance1.con); // test1\nconsole.log(instance1.getAge()); // 18\nconsole.log(instance1.getName()); // hang\n```\n\n优点：弥补了 **原型继承** 和 **构造函数** 的缺点 \n缺点：父类构造函数调用了两次\n\n## 7.4 原型式继承\n\n原型式继承并没有使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，例如：\n\n```js\nfunction createObject(o) {\n  function newOrient () {};\n  newOrient.prototype = o;\n  return new newOrient();\n}\n```\n\n简单来说`createObject`函数，对传入的`o`对象进行的一次浅拷贝。在ES5中新增加了一个方法`Object.create()`, 它的作用和`createObject`是一样的，但是只支持IE9+。\n\n```js\nvar Dogs = {\n  name: 'jingmao',\n  age: 1\n}\n\nvar BigDogs = Object.create(Dogs);\nBigDogs.name= 'bigjingmao';\nBigDogs.size = 'big';\nconsole.log(BigDogs.age);\n```\n\n其中`Object.create`还支持传入第二个参数，参数与`Object.defineProperties()`方法的格式相同，并且会覆盖原型上的同名属性。\n\n## 7.5 寄生式继承\n\n**寄生式继承** 其实和 **原型式继承** 很类似，区别在于，**寄生式继承** 创建的一个函数把所有的事情做完了，例如给新的对象增加属性和方法。\n\n```js\nfunction createAnother(o) {\n  var clone = Object.create(o);\n  clone.size = 'big';\n  return clone;\n}\n\nvar Dogs = {\n  name: 'jingmao',\n  age: 1\n}\n\nvar BigDogs = createAnother(Dogs);\nconsole.log(BigDogs.size);\n```\n\n## 7.6 寄生组合式继承\n\n到最后一个了，看看我们之前遗留的问题: \n**组合继承** 会调用两次父对象的构造函数，并且父类型的属性存在两组，一组在实例上，一组在SubType的原型上。解决这个问题的方法就是 **寄生组合式继承**。\n\n```js\nfunction inheritPrototype(subType, superType){ \n  // 继承父类的原型\n  var prototype = Object.create(superType.prototype);\n  // 重写被污染的construct\n  prototype.constructor = subType; \n  // 重写子类的原型  \n  subType.prototype = prototype; \n}\n```\n\n这个函数就是 **寄生组合式继承** 的最简单的实现方式\n\n```js\nfunction SuperType(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\n\nSuperType.prototype.sayName = function(){\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function(){ \n  alert(this.age);\n};\n\nvar instance1 = new SubType('hello', 18);\n\ninstance1.__proto__.constructor == SubType\n```\n\n可以看到\n\n1. 子类继承了父类的属性和方法，同时属性没有创建在原型链上，因此多个子类不会共享同一个属性。\n2. 子类可以动态传递参数给父类\n3. 父类构造函数只执行了一次\n\n但是还有一个问题：\n子类如果在原型上添加方法，必须要在继承之后添加，否则会覆盖原来原型上的方法。但是如果这两个类是已存在的类，就不行了\n\n优化一下：\n\n```js\nfunction inheritPrototype(subType, superType){ \n  // 继承父类的原型\n  var prototype = Object.create(superType.prototype);\n  // 重写被污染的construct\n  prototype.constructor = subType; \n  // 重写子类的原型  \n  subType.prototype = Object.assign(prototype, subType.prototype); \n}\n```\n\n虽然通过`Object.assign`来进行`copy`解决了覆盖原型类型的方法的问题，但是`Object.assign`只能够拷贝可枚举的方法，而且如果子类本身就继承了一个类，这个办法也不行。\n\n# 八、ES6 实现继承\n\n我们知道了ES5中可以通过原型链来实现继承，ES6提供了extends关键字来实现继承，这相对而言更加清晰和方便，首先看看ES6 Class的语法，此处参考[http://es6.ruanyifeng.com/#docs/class](http://es6.ruanyifeng.com/#docs/class)\n","source":"_posts/js/other/oop_extend.md","raw":"---\ntitle: JavaScript面向对象程序设计\ndate: 2018-07-02 23:01:02\ntags: [ 面向对象, 继承 ]\ncategories: [ JS ]\npublished: true\n---\n**JavaScript面向对象程序设计**\n本文会碰到的知识点：\n原型、原型链、函数对象、普通对象、继承\n\n读完本文，可以学到\n\n* 面向对象的基本概念\n* JavaScript对象属性\n* 理解JavaScript中的函数对象与普通对象\n* 理解`prototype`和`proto`\n* 理解原型和原型链\n* 详解原型链相关的Object方法\n* 了解如何用ES5模拟类，以及各种方式的优缺点\n* 了解如何用ES6实现面向对象\n\n# 一、面向对象的基本概念\n\n面向对象也即是OOP，Object Oriented Programming，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例，但是JavaScript中没有类的概念，而是直接使用对象来实现编程。\n特性：\n\n* 封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。\n\n由于JavaScript没有`public`、`private`、`protected`这些关键字，但是可以利用变量的作用域来模拟public和private封装特性\n\n```js\nvar insObject = (function() {\n  var _name = 'hello'; // private\n  return {\n    getName: function() { // public\n      return _name;\n    }\n  }\n})();\n\ninsObject._name; // undefined\ninsObject.getName(); // hello\n```\n\n这里只是实现了一个简单的版本，private比较好的实现方式可以参考深入理解`ES6 145页`,protected可以利用ES6的Symbol关键字来实现，这里不展开，有兴趣可以讨论\n\n**继承**：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写，后面的章节详细描述\n\n# 二、JavaScript对象属性\n\n想弄懂面向对象，是不是先看看对象是啥呢？\n我们先看一个题目:\n\n```js\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n```\n\n解释：\n在第一行中，`{}`出现在`+`操作符的表达式中，因此被翻译为一个实际的值（一个空`object`）。而`[]`被强制转换为\"\",因此`{}`也会被强制转换为一个`string:\"[object Object]\"`。 \n但在第二行中，`{}`被翻译为一个独立的`{}`空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，`+ []`是一个将`[]`明确强制转换 为`number`的表达式，而它的值是`0`。\n\n## 2.1 属性\n\n*对象的属性*\n\n* `Object.prototype` Object 的原型对象，不是每个对象都有`prototype`属性\n* `Object.prototype.proto` 不是标准方法，不鼓励使用，每个对象都有`proto`属性，但是由于浏览器实现方式的不同，`proto`属性在chrome、firefox中实现了，在IE中并不支持，替代的方法是`Object.getPrototypeOf()`\n* `Object.prototype.constructor`：用于创建一个对象的原型，创建对象的构造函数\n\n可能大家会有一个疑问，为什么上面那些属性要加上`prototype`\n在chrome中打印一下`var a = { test: 'test' }`\n\n*属性描述符*\n数据属性：\n\n| 特性名称 | 描述 | 默认值 |\n| - | - | - |\n| value | 属性的值 | undfined |\n| writable | 是否可以修改属性的值，true表示可以，false表示不可以 | true |\n| enumerable | 属性值是否可枚举，true表示可枚举for-in, false表示不可枚举 | true |\n| configurable | 属性的特性是否可配置，表示能否通过delete删除属性后重新定义属性 | true |\n例子:\n![img](//sml-myoss.oss-cn-beijing.aliyuncs.com/blog/word_img/20180702231814.png)\n\n访问器属性：\n\n| 特性名称 | 描述 | 默认值 |\n| - | - | - |\n| set | 设置属性时调用的函数 | undefined |\n| get | 写入属性时调用的函数 | undefined |\n| configurable | 表示能否通过delete删除属性后重新定义属性 | true |\n| enumerable | 表示能否通过for-in循环返回属性 | true |\n\n访问器属性不能直接定义，一般是通过`Object.defineProperty()`方法来定义，但是这个方法只支持IE9+， 以前一般用两个非标准方法来实现`__defineGetter__()`和֖`__defineSetter__() `\n\n例子：\n\n```js\nvar book = { _year: 2004, edition: 1 };\n\nObject.defineProperty(book, \"year\", {\n  get: function(){\n    return this._year;\n  },\n  set: function(newValue){\n    if (newValue > 2004){\n      this._year = newValue;\n      this.edition += newValue - 2004;\n    }\n  }\n});\n\nbook.year = 2005; \nalert(book.edition);\n```\n\n## 2.2 方法\n\n* `Object.prototype.toString()` 返回对象的字符串表示\n* `Object.prototype.hasOwnProperty()` 返回一个布尔值，表示某个对象是否含有指定的属性，而且此属性非原型链继承，也就是说不会检查原型链上的属性\n* `Object.prototype.isPrototypeOf()` 返回一个布尔值，表示指定的对象是否在本对象的原型链中\n* `Object.prototype.propertyIsEnumerable()` 判断指定属性是否可枚举\n* `Object.prototype.watch()` 给对象的某个属性增加监听\n* `Object.prototype.unwatch()` 移除对象某个属性的监听\n* `Object.prototype.valueOf()` 返回指定对象的原始值\n* 获取和设置属性\n  * `Object.defineProperty` 定义单个属性\n  * `Object.defineProperties` 定义多个属性\n  * `Object.getOwnPropertyDescriptor` 获取属性\n* `Object.assign()` 拷贝可枚举属性 （ES6新增）\n* `Object.create()` 创建对象\n* `Object.entries()` 返回一个包含由给定对象所有可枚举属性的属性名和属性值组成的 [属性名，属性值] 键值对的数组，数组中键值对的排列顺序和使用for…in循环遍历该对象时返回的顺序一致\n* `Object.freeze()` 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象\n* `Object.getOwnPropertyNames()` 返回指定对象的属性名组成的数组\n* `Object.getPrototypeOf` 返回该对象的原型\n* `Object.is(value1, value2)` 判断两个值是否是同一个值 (ES6 新增)\n* `Object.keys()` 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致\n* `Object.setPrototypeOf(obj, prototype)` 将一个指定的对象的原型设置为另一个对象或者null\n* `Object.values` 返回一个包含指定对象所有的可枚举属性值的数组，数组中的值顺序和使用for…in循环遍历的顺序一样\n\n## 2.3 应用\n\n如何检测某个属性是否在对象中？\n\n* in运算符，判断对象是否包含某个属性，会从对象的实例属性、继承属性里进行检测\n\n```js\nfunction Dogs(name) {\n  this.name = name\n}\n\nfunction BigDogs(size) {\n  this.size = size;\n}\n\nBigDogs.prototype = new Dogs();\n\nvar a = new BigDogs('big');\n\n'size' in a;\n'name' in a;\n'age' in a;\n```\n\n* Object.hasOwnProperty()，判断一个对象是否有指定名称的属性，不会检查继承属性\n\n```js\na.hasOwnProperty('size');\na.hasOwnProperty('name');\na.hasOwnProperty('age');\n```\n\n* `Object.propertyIsEnumerable()`，判断指定名称的属性是否为实例属性并且是可枚举的\n\n```js\n// es6\nvar a = Object.create({}, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  }\n});\n\n// es5\nvar b = {};\nObject.defineProperties(b, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  } \n});\n\na.propertyIsEnumerable('name');\na.propertyIsEnumerable('age');\n```\n\n* 如何枚举对象的属性，并保证不同了浏览器中的行为是一致的？\n\n`for/in` 语句，可以遍历可枚举的实例属性和继承属性\n\n```js\nvar a = {\n  supername: 'super hello',\n  superage: 'super name',\n}\nvar b = {};\nObject.defineProperties(b, {\n  name: {\n    value: 'hello',\n    enumerable: true,\n  },\n  age: {\n    value: 11,\n    enumerable: false,\n  }\n});\n\nObject.setPrototypeOf(b, a); // 设置b的原型是a 等效的是b.__proto__ = a\n\nfor(pro in b) {\n  console.log(pro); // name, supername, superage\n}\n```\n\n* `Object.keys()`， 返回一个数组，内容是对象可枚举的实例属性名称\n\n```js\nvar propertyArray = Object.keys(b); // name\n```\n\n* `Object.getOwnPropertyNames()`，返回一个数组，内容是对象所有实例属性，包括可枚举和不可枚举\n\n```js\nvar propertyArray = Object.getOwnPropertyNames(b); // name, age\n```\n\n* 如何判断两个对象是否相等？\n\n我只想说，这个问题说简单很简单，说复杂也挺复杂的[传送门](https://stackoverflow.com/questions/1068834/object-comparison-in-javascript)\n我们看个简单版的\n\n```js\nfunction isEquivalent(a, b) {\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length != bProps.length){\n    return false;\n  }\n\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Outputs: true\nconsole.log(isEquivalent({a:1},{a:1}));\n```\n\n上面这个函数还有啥问题呢\n\n* 没有对传入参数进行校验，例如判断是否是NaN，或者是其他内置属性\n* 没有判断传入对象的construct和prototype\n* 时间算法复杂度是O(n2)\n\n有同学可能会有疑问，能不能用`Object.is`，答案是否定的，`Object.is`简单来说就是在`===`的基础上特别处理了`NaN`，`+0`，`-0`，保证了`-0`和`+0`不相同，`Object.is(NaN, NaN)`返回`true`。\n\n* 对象的深拷贝和浅拷贝\n\n其实如果大家理解了上面的那些方法，是很容易写出深拷贝和浅拷贝的代码的，我们先看一下这两者的却别。\n浅拷贝仅仅是复制引用，拷贝后`a === b`， 注意`Object.assign`方法实现的是浅复制（此处有深刻教训！！！）\n深拷贝这是创建了一个新的对象，然后把旧的对象中的属性和方法拷贝到新的对象中，拷贝后 `a !== b`\n深拷贝的实现由很多例子，例如`jQuery`的`extend`和`lodash中的cloneDeep`, clone。jQuery可以使用`$.extend(true, {}, ...)`来实现深拷贝, 但是jQuery无法复制JSON对象之外的对象，例如ES6引入的`Map`、`Set`等。而lodash加入的大量的代码来实现ES6新引入的标准对象\n\n# 三、对象分为函数对象和普通对象\n\n** 什么是函数对象和普通对象？**\n`Object`、`Function`、`Array`、`Date`等js的内置对象都是函数对象\n\n```js\nfunction a1 () {}\nconst a2 = function () {}\nconst a3 = new Function();\n\nconst b1 = {};\nconst b2 = new Object();\n\nconst c1 = [];\nconst c2 = new Array();\n\nconst d1 = new a1();\nconst d2 = new b1(); // ????\nconst d3 = new c1(); // ????\n\ntypeof a1;\ntypeof a2;\ntypeof a3;\n\ntypeof b1;\ntypeof b2;\n\ntypeof c1;\ntypeof c2;\n\ntypeof d1;\n```\n\n上面两行报错的原因，是因为构造函数只能由函数来充当，而b1和c1不是Function的实例，所以不能充当构造器\n** 但是只有Function的实例都是函数对象、其他的实例都是普通对象 **\n我们延伸一下，在看个例子\n\n```js\nconst e1 = function *(){};\nconst e2 = new e1();\n// Uncaught TypeError: e1 is not a constructor\nconsole.log(e1.constructor) // 是有值的。。。\n// 规范里面就不能new\nconst e2 = e1();\n```\n\n`GeneratorFunction`是一个特殊的函数对象 \n`e1.__proto__.__proto__ === Function.prototype`\n\n`e1`的原型实际上是一个生成器函数`GeneratorFunction`，也就是说 \n`e1.__proto__ === GeneratorFunction.prototype`\n\n这行代码有问题么，啊哈哈哈，`GeneratorFunction`这个关键字主流的JavaScript还木有暴露出来，所以这个大家理解就好啦\n\n虽然不能直接`new e1`\n但是可以`new e1.constructor();`哈哈哈哈\n\n# 四、理解prototype和proto\n\n| 对象类型 | prototype | proto |\n| - | - |\n| 函数对象 | Yes | Yes |\n| 普通对象 | No | Yes |\n\n* 只有函数对象具有`prototype`这个属性\n* `prototype`和`__proto__`都是js在定义一个对象时的预定义属性\n* `prototype`是被实例的`__proto__`指向\n* `__proto__`指向构造函数的`prototype`\n\n```js\nconst a = function(){}\nconst b = {}\n\ntypeof a // function\ntypeof b // object\n\ntypeof a.prototype // object\ntypeof a.__proto__ // function\n\ntypeof b.prototype // undefined\ntypeof b.__proto__ // object\n\na.__proto__ === Function.prototype\nb.__proto__ === Object.prototype\n```\n\n理解了`prototype`和`__proto__`之后，我们来看看之前一直说的为什么JavaScript里面都是对象\n\n```js\nconst a = {}\nconst b = function () {}\nconst c = []\nconst d = new Date()\n\na.__proto__\na.__proto__ === Object.prototype\n\nb.__proto__\nb.__proto__ === Function.prototype\n\nc.__proto__\nc.__proto__ === Array.prototype\n\nd.__proto__\nd.__proto__ === Date.prototype\n\nObject.prototype.__proto__ //null\n\nFunction.prototype.__proto__ === Object.prototype\n\nArray.prototype.__proto__ === Object.prototype\n\nDate.prototype.__proto__ === Object.prototype\n```\n\n延伸一个问题：如何判断一个变量是否是数组？\n\n* typeof\n\n我们上面已经解释了，这些都是普通对象，普通对象是没有`prototype`的，他们`typeof`的值都是`object`\n\n```js\ntypeof []\ntypeof {}\n```\n\n从原型来看, 原理就是看Array是否在a的原型链中\na的原型链是 Array->Object\n\n```js\nconst a = [];\nArray.prototype.isPrototypeOf(obj);\n```\n\n* instanceof\n\n```js\nconst a = [];\na instanceof Array\n```\n\n从构造函数入手，但是这个方法和上面的方法都有一问题，不同的框架中创建的数组不会相互共享其`prototype`属性\n根据对象的class属性，跨原型调用`tostring`方法\n\n```js\nconst a = [];\nObject.prototype.toString.call(a);\n// [Object Array]\n```\n\nES5 中所有内置对象的[[Class]]属性的值是由规范定义的，但是 ES6 中已经没有了[[Class]]属性，取代它的是[[NativeBrand]]属性，这个大家有兴趣可以自行去查看规范 \n原理：\n\n1. 如果`this`的值为`undefined`,则返回`'[object Undefined]'`. \n2. 如果`this`的值为`null`,则返回`[object Null]`. \n3. 让`O`成为调用`ToObject(this)`的结果. \n4. 让`class`成为`O`的内部属性`[[Class]]`的值. \n5. 返回三个字符串`'[object '`, `'class'`, 以及 `']'`连接后的新字符串.\n\n问题？这个一定是正确的么？不正确为啥？ \n提示ES6的`Symbol`属性\n`Array.isArray()` \n部分浏览器中不兼容\n\n# 五、理解原型与原型链\n\n其实上一节中的`prototype`和`proto`就是为了构建原型链而存在的，之前也或多或少的说到了原型链这个概念。\n\n看下面的代码:\n\n```js\nconst Dogs = function(name) {\n    this.name = name;\n}\n\nDogs.prototype.getName = function() {\n    return this.name\n}\n\nconst sijing = new Dogs('sijing');\nconsole.log(sijing);\nconsole.log(sijing.getName());\n```\n\n这段代码的执行过程\n\n1. 首先创建了一个构造函数`Dogs`，传入一个参数`name`，`Dogs.prototype`也会自动创建\n2. 给对象`dogs`增加了一个方法 \n3. 通过构造函数`Dogs`实例化了一个对象`sijing`\n4. 输出`sijing`的值,可以看到`sijing`有两个值`name`和`proto`,其中`proto`指向`Dogs.prototype`\n5. 执行`getName`方法时，在`sijing`中找不到这个方法，就会继续向着原型链继续往上找，也就是通过`proto`，然后就找到了`getName`方法。\n\n这个过程实际上就是原型继承，实际上JavaScript的原型继承就是利用了`proto`并借助`prototype`来实现的。\n\n```js\nsijing.__proto__ === Function.prototype\n\nDogs.prototype // 指向什么\nDogs.prototype.__proto__ // 指向什么\nDogs.prototype.__proto__.__proto__ // 指向什么\n```\n\n上面例子中`getName`最终是查找到了，那么如果在原型链中一直没查找到，会怎么样？ \n例如`console.log(sijing.age)`\n\n```js\nsijing // 是一个对象可以继续\nsijing.age // 不存在，继续\nsijing.__proto__ // 是一个对象可以继续\nsijing.__proto__.age // 不存在，继续\nsijing.__proto__.__proto__ // 是个对象可以继续\nsijing.__proto__.__proto__.age // 不存在，继续\nsijing.__proto__.__proto__.__proto__ null，// 不是对象，到头啦\n```\n\n**原型链** 的概念其实不重要，重要的是要理解，简单来说，原型链就是利用原型让一个引用类型继承另一个应用类型的属性和方法。\n\n还有三点需要注意的:\n\n* 任何内置函数对象（类）本身的 `_proto_`都指向`Function`的原型对象；\n* 除了`Object`的原型对象的`_proto_`指向`null`，其他所有内置函数对象的原型对象的`_proto_`都指向`object`。\n* 所有构造函数的的`prototype`方法的`proto`都指向`Object.prototype`（除了….`Object.prototype`自身）\n\n如果理解了上面这些内容，大家可以自行描述一下，构造函数、原型和实例之间的关系.\n\n* 构造函数首字母必须大写，用来区分普通函数，内部使用`this`指针，指向要生成的实例对象，通过`new`来生成实例对象。 \n* 实例就是通过`new`一个构造函数产生的对象，它有一个属性`[[prototype]]`指向原型 \n* 原型中有一个属性`[[constructor]]`，指向构造函数\n\n# 六、与原型链相关的方法\n\n## 6.1 hasOwnProperty\n\n`Object.hasOwnProperty()`返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有`in`操作符，`in`操作符只要属性存在，不管实在实例中还是原型中，就会返回`true`。同时使用`in`和`hasOwnProperty`就可以判断属性是在原型中还是在实例中\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(14);\nsijing.hasOwnProperty('age');\n```\n\n## 6.2 isPrototypeOf\n\n`Object.prototype.isPrototypeOf()`返回一个布尔值，表示指定的对象是否在本对象的原型链中\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(11);\nObject.prototype.isPrototypeOf(Dogs);\nDogs.prototype.isPrototypeOf(sijing);\n```\n\n## 6.3 getPrototypeOf\n\n`Object.getPrototypeOf`返回该对象的原型\n\n```js\nconst Dogs = function (age) {\n  this.age = age\n}\n\nDogs.prototype.getAge = function() {\n  return this.age;\n}\n\nconst sijing = new Dogs(11);\nsijing.__proto__ === Object.getPrototypeOf(sijing) \n```\n\n# 七、ES5 对象继承\n\n## 7.1 原型继承\n\n原型继承就是利用** 原型链 **来实现继承\n\n```js\nfunction SuperType() {\n  this.supername = 'super';\n}\n\nSuperType.prototype.getSuperName= function(){\n  return this.supername;\n}\n\nfunction SubType () {\n  this.subname='subname';\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.getSubName = function (){\n  return this.subname;\n}\n\nvar instance1 = new SubType();\nconsole.log(instance1.getSubName());\nconsole.log(instance1.getSuperName());\n```\n\n需要注意的地方： \n实现原型继承的时候不要使用对象字面量创建原型方法，因为这样做，会重写原型链。\n\n```js\nfunction SuperType() {\n  this.supername = 'super';\n}\n\nSuperType.prototype.getSuperName= function(){\n  return this.supername;\n}\n\nfunction SubType () {\n  this.subname='subname';\n}\n\nSubType.prototype = new SuperType();\n\nSubType.prototype =  {\n  getSubName: function (){\n    return this.subname;\n  }\n}\n\nvar instance1 = new SubType();\nconsole.log(instance1.getSubName());\nconsole.log(instance1.getSuperName()); // error\n```\n\n上面使用`SubType.prototype = {...}`之后，`SubType`的原型就是`Object`了，而不是`SuperType`了。\n\n优点：原型定义的属性和方法可以复用\n缺点：\n\n1. 引用类型的原型属性会被所有实例共享 \n2. 创建子对象时，不能向父对象的构造函数中传递参数\n\n## 7.2 构造函数继承\n\n```js\nvar a = {\n  name: 'a',\n};\n\nvar name = 'window';\n\nvar getName = function(){\n  console.log(this.name);\n}\n\ngetName() // window\ngetName.call(a) // a\n```\n\n执行`getName()`时，函数体的`this`指向`window`，而执行`getName.call(a)`时，函数体的`this`指向的是`a`对象，所以就可以理解啦。接下来我们看如何实现构造函数继承\n\n```js\nfunction SuperType () {\n  this.colors = ['red', 'green'];\n}\n\nfunction SubType () {\n  // 继承SuperType\n  SuperType.call(this);\n}\n\nvar instance1 = new SubType();\ninstance1.colors.push('blue'); \nconsole.log(instance1.colors); // red, green, blue\n\nvar instance2 = new SubType();\nconsole.log(instance2.colors); // red, green\n```\n\n`SuperType.call(this)`这一行代码，实际上意思是在`SubType`的实例初始化过程中，调用了`SuperType`的构造函数，因此`SubType`的每个实例都有`colors`这个属性\n\n优点：子对象可以传递参数给父对象。\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\nfunction SubType(name, age) {\n  name = name || 'hello';\n  SuperType.call(this, name);\n  this.age = age;\n}\n\nvar instance1 = new SubType('scofield', 28);\nconsole.log(instance1.name); //\nconsole.log(instance1.age); //\n```\n\n需要注意的地方是在调用父对象的构造函数之后，再给子类型中的定义属性，否则会被重写。\n\n缺点：方法都需要在构造函数中定义，难以做到函数的复用，而且在父对象的原型上定义的方法，对于子类型是不可见的。 ??? 为什么不可见\n\n```js\nfunction SuperType(name) {\n  this.name = name;\n}\n\nSuperType.prototype.getName = function() {\n  return this.name;\n}\n\nSuperType.prototype.prefix = function() {\n  return 'prefix';\n}\n\nfunction SubType(name) {\n  SuperType.call(this, name);\n}\n\nvar instance1 = new SubType('scofield');\nconsole.log(instance1.name);\nconsole.log(instance1.prefix);\nconsole.log(instance1.getName()); // Uncaught TypeError: instance1.getName is not a function\n```\n\n## 7.3 组合式继承\n\n**组合式继承** 顾名思义，就是组合两种模式实现JavaScript的继承，借助 **原型链** 和 **构造函数** 来实现。这样子在原型上定义方法实现了函数的复用，而且能够保证每个实例都有自己的属性。\n\n```js\nfunction SuperType (name) {\n  this.name = name;\n  this.con = [];\n}\n\nSuperType.prototype.getName = function() {\n  return this.name;\n}\n\nfunction SubType (name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.constructor = SubType;\nSubType.prototype.getAge = function() {\n  return this.age;\n};\n\nvar instance1 = new SubType('li', 18);\ninstance1.con.push('test1');\nconsole.log(instance1.con); // test1\nconsole.log(instance1.getAge()); // 18\nconsole.log(instance1.getName()); // li\n\nvar instance2 = new SubType('hang', 18);\nconsole.log(instance1.con); // test1\nconsole.log(instance1.getAge()); // 18\nconsole.log(instance1.getName()); // hang\n```\n\n优点：弥补了 **原型继承** 和 **构造函数** 的缺点 \n缺点：父类构造函数调用了两次\n\n## 7.4 原型式继承\n\n原型式继承并没有使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，例如：\n\n```js\nfunction createObject(o) {\n  function newOrient () {};\n  newOrient.prototype = o;\n  return new newOrient();\n}\n```\n\n简单来说`createObject`函数，对传入的`o`对象进行的一次浅拷贝。在ES5中新增加了一个方法`Object.create()`, 它的作用和`createObject`是一样的，但是只支持IE9+。\n\n```js\nvar Dogs = {\n  name: 'jingmao',\n  age: 1\n}\n\nvar BigDogs = Object.create(Dogs);\nBigDogs.name= 'bigjingmao';\nBigDogs.size = 'big';\nconsole.log(BigDogs.age);\n```\n\n其中`Object.create`还支持传入第二个参数，参数与`Object.defineProperties()`方法的格式相同，并且会覆盖原型上的同名属性。\n\n## 7.5 寄生式继承\n\n**寄生式继承** 其实和 **原型式继承** 很类似，区别在于，**寄生式继承** 创建的一个函数把所有的事情做完了，例如给新的对象增加属性和方法。\n\n```js\nfunction createAnother(o) {\n  var clone = Object.create(o);\n  clone.size = 'big';\n  return clone;\n}\n\nvar Dogs = {\n  name: 'jingmao',\n  age: 1\n}\n\nvar BigDogs = createAnother(Dogs);\nconsole.log(BigDogs.size);\n```\n\n## 7.6 寄生组合式继承\n\n到最后一个了，看看我们之前遗留的问题: \n**组合继承** 会调用两次父对象的构造函数，并且父类型的属性存在两组，一组在实例上，一组在SubType的原型上。解决这个问题的方法就是 **寄生组合式继承**。\n\n```js\nfunction inheritPrototype(subType, superType){ \n  // 继承父类的原型\n  var prototype = Object.create(superType.prototype);\n  // 重写被污染的construct\n  prototype.constructor = subType; \n  // 重写子类的原型  \n  subType.prototype = prototype; \n}\n```\n\n这个函数就是 **寄生组合式继承** 的最简单的实现方式\n\n```js\nfunction SuperType(name){\n  this.name = name;\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\n\nSuperType.prototype.sayName = function(){\n  alert(this.name);\n};\n\nfunction SubType(name, age) {\n  SuperType.call(this, name);\n  this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function(){ \n  alert(this.age);\n};\n\nvar instance1 = new SubType('hello', 18);\n\ninstance1.__proto__.constructor == SubType\n```\n\n可以看到\n\n1. 子类继承了父类的属性和方法，同时属性没有创建在原型链上，因此多个子类不会共享同一个属性。\n2. 子类可以动态传递参数给父类\n3. 父类构造函数只执行了一次\n\n但是还有一个问题：\n子类如果在原型上添加方法，必须要在继承之后添加，否则会覆盖原来原型上的方法。但是如果这两个类是已存在的类，就不行了\n\n优化一下：\n\n```js\nfunction inheritPrototype(subType, superType){ \n  // 继承父类的原型\n  var prototype = Object.create(superType.prototype);\n  // 重写被污染的construct\n  prototype.constructor = subType; \n  // 重写子类的原型  \n  subType.prototype = Object.assign(prototype, subType.prototype); \n}\n```\n\n虽然通过`Object.assign`来进行`copy`解决了覆盖原型类型的方法的问题，但是`Object.assign`只能够拷贝可枚举的方法，而且如果子类本身就继承了一个类，这个办法也不行。\n\n# 八、ES6 实现继承\n\n我们知道了ES5中可以通过原型链来实现继承，ES6提供了extends关键字来实现继承，这相对而言更加清晰和方便，首先看看ES6 Class的语法，此处参考[http://es6.ruanyifeng.com/#docs/class](http://es6.ruanyifeng.com/#docs/class)\n","slug":"js/other/oop_extend","updated":"2018-08-01T02:42:17.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46pb000b0qr4r256edsu","content":"<p><strong>JavaScript面向对象程序设计</strong><br>本文会碰到的知识点：<br>原型、原型链、函数对象、普通对象、继承</p>\n<p>读完本文，可以学到</p>\n<ul>\n<li>面向对象的基本概念</li>\n<li>JavaScript对象属性</li>\n<li>理解JavaScript中的函数对象与普通对象</li>\n<li>理解<code>prototype</code>和<code>proto</code></li>\n<li>理解原型和原型链</li>\n<li>详解原型链相关的Object方法</li>\n<li>了解如何用ES5模拟类，以及各种方式的优缺点</li>\n<li>了解如何用ES6实现面向对象</li>\n</ul>\n<h1 id=\"一、面向对象的基本概念\"><a href=\"#一、面向对象的基本概念\" class=\"headerlink\" title=\"一、面向对象的基本概念\"></a>一、面向对象的基本概念</h1><p>面向对象也即是OOP，Object Oriented Programming，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例，但是JavaScript中没有类的概念，而是直接使用对象来实现编程。<br>特性：</p>\n<ul>\n<li>封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。</li>\n</ul>\n<p>由于JavaScript没有<code>public</code>、<code>private</code>、<code>protected</code>这些关键字，但是可以利用变量的作用域来模拟public和private封装特性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> insObject = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = <span class=\"string\">'hello'</span>; <span class=\"comment\">// private</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// public</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> _name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">insObject._name; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">insObject.getName(); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n<p>这里只是实现了一个简单的版本，private比较好的实现方式可以参考深入理解<code>ES6 145页</code>,protected可以利用ES6的Symbol关键字来实现，这里不展开，有兴趣可以讨论</p>\n<p><strong>继承</strong>：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写，后面的章节详细描述</p>\n<h1 id=\"二、JavaScript对象属性\"><a href=\"#二、JavaScript对象属性\" class=\"headerlink\" title=\"二、JavaScript对象属性\"></a>二、JavaScript对象属性</h1><p>想弄懂面向对象，是不是先看看对象是啥呢？<br>我们先看一个题目:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\">&#123;&#125; + []; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>解释：<br>在第一行中，<code>{}</code>出现在<code>+</code>操作符的表达式中，因此被翻译为一个实际的值（一个空<code>object</code>）。而<code>[]</code>被强制转换为””,因此<code>{}</code>也会被强制转换为一个<code>string:&quot;[object Object]&quot;</code>。<br>但在第二行中，<code>{}</code>被翻译为一个独立的<code>{}</code>空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，<code>+ []</code>是一个将<code>[]</code>明确强制转换 为<code>number</code>的表达式，而它的值是<code>0</code>。</p>\n<h2 id=\"2-1-属性\"><a href=\"#2-1-属性\" class=\"headerlink\" title=\"2.1 属性\"></a>2.1 属性</h2><p><em>对象的属性</em></p>\n<ul>\n<li><code>Object.prototype</code> Object 的原型对象，不是每个对象都有<code>prototype</code>属性</li>\n<li><code>Object.prototype.proto</code> 不是标准方法，不鼓励使用，每个对象都有<code>proto</code>属性，但是由于浏览器实现方式的不同，<code>proto</code>属性在chrome、firefox中实现了，在IE中并不支持，替代的方法是<code>Object.getPrototypeOf()</code></li>\n<li><code>Object.prototype.constructor</code>：用于创建一个对象的原型，创建对象的构造函数</li>\n</ul>\n<p>可能大家会有一个疑问，为什么上面那些属性要加上<code>prototype</code><br>在chrome中打印一下<code>var a = { test: &#39;test&#39; }</code></p>\n<p><em>属性描述符</em><br>数据属性：</p>\n<table>\n<thead>\n<tr>\n<th>特性名称</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>属性的值</td>\n<td>undfined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>是否可以修改属性的值，true表示可以，false表示不可以</td>\n<td>true</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>属性值是否可枚举，true表示可枚举for-in, false表示不可枚举</td>\n<td>true</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>属性的特性是否可配置，表示能否通过delete删除属性后重新定义属性</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>例子:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"//sml-myoss.oss-cn-beijing.aliyuncs.com/blog/word_img/20180702231814.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure></p>\n<p>访问器属性：</p>\n<table>\n<thead>\n<tr>\n<th>特性名称</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set</td>\n<td>设置属性时调用的函数</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>写入属性时调用的函数</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>表示能否通过delete删除属性后重新定义属性</td>\n<td>true</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>表示能否通过for-in循环返回属性</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>访问器属性不能直接定义，一般是通过<code>Object.defineProperty()</code>方法来定义，但是这个方法只支持IE9+， 以前一般用两个非标准方法来实现<code>__defineGetter__()</code>和֖<code>__defineSetter__()</code></p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123; <span class=\"attr\">_year</span>: <span class=\"number\">2004</span>, <span class=\"attr\">edition</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(book, <span class=\"string\">\"year\"</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._year;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2004</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._year = newValue;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.edition += newValue - <span class=\"number\">2004</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = <span class=\"number\">2005</span>; </span><br><span class=\"line\">alert(book.edition);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-方法\"><a href=\"#2-2-方法\" class=\"headerlink\" title=\"2.2 方法\"></a>2.2 方法</h2><ul>\n<li><code>Object.prototype.toString()</code> 返回对象的字符串表示</li>\n<li><code>Object.prototype.hasOwnProperty()</code> 返回一个布尔值，表示某个对象是否含有指定的属性，而且此属性非原型链继承，也就是说不会检查原型链上的属性</li>\n<li><code>Object.prototype.isPrototypeOf()</code> 返回一个布尔值，表示指定的对象是否在本对象的原型链中</li>\n<li><code>Object.prototype.propertyIsEnumerable()</code> 判断指定属性是否可枚举</li>\n<li><code>Object.prototype.watch()</code> 给对象的某个属性增加监听</li>\n<li><code>Object.prototype.unwatch()</code> 移除对象某个属性的监听</li>\n<li><code>Object.prototype.valueOf()</code> 返回指定对象的原始值</li>\n<li>获取和设置属性<ul>\n<li><code>Object.defineProperty</code> 定义单个属性</li>\n<li><code>Object.defineProperties</code> 定义多个属性</li>\n<li><code>Object.getOwnPropertyDescriptor</code> 获取属性</li>\n</ul>\n</li>\n<li><code>Object.assign()</code> 拷贝可枚举属性 （ES6新增）</li>\n<li><code>Object.create()</code> 创建对象</li>\n<li><code>Object.entries()</code> 返回一个包含由给定对象所有可枚举属性的属性名和属性值组成的 [属性名，属性值] 键值对的数组，数组中键值对的排列顺序和使用for…in循环遍历该对象时返回的顺序一致</li>\n<li><code>Object.freeze()</code> 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象</li>\n<li><code>Object.getOwnPropertyNames()</code> 返回指定对象的属性名组成的数组</li>\n<li><code>Object.getPrototypeOf</code> 返回该对象的原型</li>\n<li><code>Object.is(value1, value2)</code> 判断两个值是否是同一个值 (ES6 新增)</li>\n<li><code>Object.keys()</code> 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致</li>\n<li><code>Object.setPrototypeOf(obj, prototype)</code> 将一个指定的对象的原型设置为另一个对象或者null</li>\n<li><code>Object.values</code> 返回一个包含指定对象所有的可枚举属性值的数组，数组中的值顺序和使用for…in循环遍历的顺序一样</li>\n</ul>\n<h2 id=\"2-3-应用\"><a href=\"#2-3-应用\" class=\"headerlink\" title=\"2.3 应用\"></a>2.3 应用</h2><p>如何检测某个属性是否在对象中？</p>\n<ul>\n<li>in运算符，判断对象是否包含某个属性，会从对象的实例属性、继承属性里进行检测</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dogs</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BigDogs</span>(<span class=\"params\">size</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BigDogs.prototype = <span class=\"keyword\">new</span> Dogs();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> BigDogs(<span class=\"string\">'big'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'size'</span> <span class=\"keyword\">in</span> a;</span><br><span class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> a;</span><br><span class=\"line\"><span class=\"string\">'age'</span> <span class=\"keyword\">in</span> a;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Object.hasOwnProperty()，判断一个对象是否有指定名称的属性，不会检查继承属性</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'size'</span>);</span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'name'</span>);</span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.propertyIsEnumerable()</code>，判断指定名称的属性是否为实例属性并且是可枚举的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;&#125;, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(b, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">a.propertyIsEnumerable(<span class=\"string\">'name'</span>);</span><br><span class=\"line\">a.propertyIsEnumerable(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何枚举对象的属性，并保证不同了浏览器中的行为是一致的？</li>\n</ul>\n<p><code>for/in</code> 语句，可以遍历可枚举的实例属性和继承属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  supername: <span class=\"string\">'super hello'</span>,</span><br><span class=\"line\">  superage: <span class=\"string\">'super name'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(b, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(b, a); <span class=\"comment\">// 设置b的原型是a 等效的是b.__proto__ = a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(pro <span class=\"keyword\">in</span> b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pro); <span class=\"comment\">// name, supername, superage</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.keys()</code>， 返回一个数组，内容是对象可枚举的实例属性名称</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> propertyArray = <span class=\"built_in\">Object</span>.keys(b); <span class=\"comment\">// name</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.getOwnPropertyNames()</code>，返回一个数组，内容是对象所有实例属性，包括可枚举和不可枚举</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> propertyArray = <span class=\"built_in\">Object</span>.getOwnPropertyNames(b); <span class=\"comment\">// name, age</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何判断两个对象是否相等？</li>\n</ul>\n<p>我只想说，这个问题说简单很简单，说复杂也挺复杂的<a href=\"https://stackoverflow.com/questions/1068834/object-comparison-in-javascript\" target=\"_blank\" rel=\"noopener\">传送门</a><br>我们看个简单版的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isEquivalent</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> aProps = <span class=\"built_in\">Object</span>.getOwnPropertyNames(a);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bProps = <span class=\"built_in\">Object</span>.getOwnPropertyNames(b);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aProps.length != bProps.length)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; aProps.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> propName = aProps[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[propName] !== b[propName]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Outputs: true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isEquivalent(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;,&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;));</span><br></pre></td></tr></table></figure>\n<p>上面这个函数还有啥问题呢</p>\n<ul>\n<li>没有对传入参数进行校验，例如判断是否是NaN，或者是其他内置属性</li>\n<li>没有判断传入对象的construct和prototype</li>\n<li>时间算法复杂度是O(n2)</li>\n</ul>\n<p>有同学可能会有疑问，能不能用<code>Object.is</code>，答案是否定的，<code>Object.is</code>简单来说就是在<code>===</code>的基础上特别处理了<code>NaN</code>，<code>+0</code>，<code>-0</code>，保证了<code>-0</code>和<code>+0</code>不相同，<code>Object.is(NaN, NaN)</code>返回<code>true</code>。</p>\n<ul>\n<li>对象的深拷贝和浅拷贝</li>\n</ul>\n<p>其实如果大家理解了上面的那些方法，是很容易写出深拷贝和浅拷贝的代码的，我们先看一下这两者的却别。<br>浅拷贝仅仅是复制引用，拷贝后<code>a === b</code>， 注意<code>Object.assign</code>方法实现的是浅复制（此处有深刻教训！！！）<br>深拷贝这是创建了一个新的对象，然后把旧的对象中的属性和方法拷贝到新的对象中，拷贝后 <code>a !== b</code><br>深拷贝的实现由很多例子，例如<code>jQuery</code>的<code>extend</code>和<code>lodash中的cloneDeep</code>, clone。jQuery可以使用<code>$.extend(true, {}, ...)</code>来实现深拷贝, 但是jQuery无法复制JSON对象之外的对象，例如ES6引入的<code>Map</code>、<code>Set</code>等。而lodash加入的大量的代码来实现ES6新引入的标准对象</p>\n<h1 id=\"三、对象分为函数对象和普通对象\"><a href=\"#三、对象分为函数对象和普通对象\" class=\"headerlink\" title=\"三、对象分为函数对象和普通对象\"></a>三、对象分为函数对象和普通对象</h1><p><strong> 什么是函数对象和普通对象？</strong><br><code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>等js的内置对象都是函数对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a1</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> c1 = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> c2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d1 = <span class=\"keyword\">new</span> a1();</span><br><span class=\"line\"><span class=\"keyword\">const</span> d2 = <span class=\"keyword\">new</span> b1(); <span class=\"comment\">// ????</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d3 = <span class=\"keyword\">new</span> c1(); <span class=\"comment\">// ????</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> d1;</span><br></pre></td></tr></table></figure>\n<p>上面两行报错的原因，是因为构造函数只能由函数来充当，而b1和c1不是Function的实例，所以不能充当构造器<br><strong> 但是只有Function的实例都是函数对象、其他的实例都是普通对象 </strong><br>我们延伸一下，在看个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e1 = <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> e2 = <span class=\"keyword\">new</span> e1();</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: e1 is not a constructor</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e1.constructor) <span class=\"comment\">// 是有值的。。。</span></span><br><span class=\"line\"><span class=\"comment\">// 规范里面就不能new</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e2 = e1();</span><br></pre></td></tr></table></figure>\n<p><code>GeneratorFunction</code>是一个特殊的函数对象<br><code>e1.__proto__.__proto__ === Function.prototype</code></p>\n<p><code>e1</code>的原型实际上是一个生成器函数<code>GeneratorFunction</code>，也就是说<br><code>e1.__proto__ === GeneratorFunction.prototype</code></p>\n<p>这行代码有问题么，啊哈哈哈，<code>GeneratorFunction</code>这个关键字主流的JavaScript还木有暴露出来，所以这个大家理解就好啦</p>\n<p>虽然不能直接<code>new e1</code><br>但是可以<code>new e1.constructor();</code>哈哈哈哈</p>\n<h1 id=\"四、理解prototype和proto\"><a href=\"#四、理解prototype和proto\" class=\"headerlink\" title=\"四、理解prototype和proto\"></a>四、理解prototype和proto</h1><table>\n<thead>\n<tr>\n<th>对象类型</th>\n<th>prototype</th>\n<th>proto</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>函数对象</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>普通对象</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>只有函数对象具有<code>prototype</code>这个属性</li>\n<li><code>prototype</code>和<code>__proto__</code>都是js在定义一个对象时的预定义属性</li>\n<li><code>prototype</code>是被实例的<code>__proto__</code>指向</li>\n<li><code>__proto__</code>指向构造函数的<code>prototype</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a.prototype <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a.__proto__ <span class=\"comment\">// function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b.prototype <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b.__proto__ <span class=\"comment\">// object</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n<p>理解了<code>prototype</code>和<code>__proto__</code>之后，我们来看看之前一直说的为什么JavaScript里面都是对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">a.__proto__</span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">b.__proto__</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">c.__proto__</span><br><span class=\"line\">c.__proto__ === <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">d.__proto__</span><br><span class=\"line\">d.__proto__ === <span class=\"built_in\">Date</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ <span class=\"comment\">//null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n<p>延伸一个问题：如何判断一个变量是否是数组？</p>\n<ul>\n<li>typeof</li>\n</ul>\n<p>我们上面已经解释了，这些都是普通对象，普通对象是没有<code>prototype</code>的，他们<code>typeof</code>的值都是<code>object</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> []</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>从原型来看, 原理就是看Array是否在a的原型链中<br>a的原型链是 Array-&gt;Object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.isPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>instanceof</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span></span><br></pre></td></tr></table></figure>\n<p>从构造函数入手，但是这个方法和上面的方法都有一问题，不同的框架中创建的数组不会相互共享其<code>prototype</code>属性<br>根据对象的class属性，跨原型调用<code>tostring</code>方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(a);</span><br><span class=\"line\"><span class=\"comment\">// [Object Array]</span></span><br></pre></td></tr></table></figure>\n<p>ES5 中所有内置对象的[[Class]]属性的值是由规范定义的，但是 ES6 中已经没有了[[Class]]属性，取代它的是[[NativeBrand]]属性，这个大家有兴趣可以自行去查看规范<br>原理：</p>\n<ol>\n<li>如果<code>this</code>的值为<code>undefined</code>,则返回<code>&#39;[object Undefined]&#39;</code>. </li>\n<li>如果<code>this</code>的值为<code>null</code>,则返回<code>[object Null]</code>. </li>\n<li>让<code>O</code>成为调用<code>ToObject(this)</code>的结果. </li>\n<li>让<code>class</code>成为<code>O</code>的内部属性<code>[[Class]]</code>的值. </li>\n<li>返回三个字符串<code>&#39;[object &#39;</code>, <code>&#39;class&#39;</code>, 以及 <code>&#39;]&#39;</code>连接后的新字符串.</li>\n</ol>\n<p>问题？这个一定是正确的么？不正确为啥？<br>提示ES6的<code>Symbol</code>属性<br><code>Array.isArray()</code><br>部分浏览器中不兼容</p>\n<h1 id=\"五、理解原型与原型链\"><a href=\"#五、理解原型与原型链\" class=\"headerlink\" title=\"五、理解原型与原型链\"></a>五、理解原型与原型链</h1><p>其实上一节中的<code>prototype</code>和<code>proto</code>就是为了构建原型链而存在的，之前也或多或少的说到了原型链这个概念。</p>\n<p>看下面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"string\">'sijing'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sijing);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sijing.getName());</span><br></pre></td></tr></table></figure>\n<p>这段代码的执行过程</p>\n<ol>\n<li>首先创建了一个构造函数<code>Dogs</code>，传入一个参数<code>name</code>，<code>Dogs.prototype</code>也会自动创建</li>\n<li>给对象<code>dogs</code>增加了一个方法 </li>\n<li>通过构造函数<code>Dogs</code>实例化了一个对象<code>sijing</code></li>\n<li>输出<code>sijing</code>的值,可以看到<code>sijing</code>有两个值<code>name</code>和<code>proto</code>,其中<code>proto</code>指向<code>Dogs.prototype</code></li>\n<li>执行<code>getName</code>方法时，在<code>sijing</code>中找不到这个方法，就会继续向着原型链继续往上找，也就是通过<code>proto</code>，然后就找到了<code>getName</code>方法。</li>\n</ol>\n<p>这个过程实际上就是原型继承，实际上JavaScript的原型继承就是利用了<code>proto</code>并借助<code>prototype</code>来实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sijing.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype <span class=\"comment\">// 指向什么</span></span><br><span class=\"line\">Dogs.prototype.__proto__ <span class=\"comment\">// 指向什么</span></span><br><span class=\"line\">Dogs.prototype.__proto__.__proto__ <span class=\"comment\">// 指向什么</span></span><br></pre></td></tr></table></figure>\n<p>上面例子中<code>getName</code>最终是查找到了，那么如果在原型链中一直没查找到，会怎么样？<br>例如<code>console.log(sijing.age)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sijing <span class=\"comment\">// 是一个对象可以继续</span></span><br><span class=\"line\">sijing.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__ <span class=\"comment\">// 是一个对象可以继续</span></span><br><span class=\"line\">sijing.__proto__.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__ <span class=\"comment\">// 是个对象可以继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__.__proto__ <span class=\"literal\">null</span>，<span class=\"comment\">// 不是对象，到头啦</span></span><br></pre></td></tr></table></figure>\n<p><strong>原型链</strong> 的概念其实不重要，重要的是要理解，简单来说，原型链就是利用原型让一个引用类型继承另一个应用类型的属性和方法。</p>\n<p>还有三点需要注意的:</p>\n<ul>\n<li>任何内置函数对象（类）本身的 <code>_proto_</code>都指向<code>Function</code>的原型对象；</li>\n<li>除了<code>Object</code>的原型对象的<code>_proto_</code>指向<code>null</code>，其他所有内置函数对象的原型对象的<code>_proto_</code>都指向<code>object</code>。</li>\n<li>所有构造函数的的<code>prototype</code>方法的<code>proto</code>都指向<code>Object.prototype</code>（除了….<code>Object.prototype</code>自身）</li>\n</ul>\n<p>如果理解了上面这些内容，大家可以自行描述一下，构造函数、原型和实例之间的关系.</p>\n<ul>\n<li>构造函数首字母必须大写，用来区分普通函数，内部使用<code>this</code>指针，指向要生成的实例对象，通过<code>new</code>来生成实例对象。 </li>\n<li>实例就是通过<code>new</code>一个构造函数产生的对象，它有一个属性<code>[[prototype]]</code>指向原型 </li>\n<li>原型中有一个属性<code>[[constructor]]</code>，指向构造函数</li>\n</ul>\n<h1 id=\"六、与原型链相关的方法\"><a href=\"#六、与原型链相关的方法\" class=\"headerlink\" title=\"六、与原型链相关的方法\"></a>六、与原型链相关的方法</h1><h2 id=\"6-1-hasOwnProperty\"><a href=\"#6-1-hasOwnProperty\" class=\"headerlink\" title=\"6.1 hasOwnProperty\"></a>6.1 hasOwnProperty</h2><p><code>Object.hasOwnProperty()</code>返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有<code>in</code>操作符，<code>in</code>操作符只要属性存在，不管实在实例中还是原型中，就会返回<code>true</code>。同时使用<code>in</code>和<code>hasOwnProperty</code>就可以判断属性是在原型中还是在实例中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">14</span>);</span><br><span class=\"line\">sijing.hasOwnProperty(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-isPrototypeOf\"><a href=\"#6-2-isPrototypeOf\" class=\"headerlink\" title=\"6.2 isPrototypeOf\"></a>6.2 isPrototypeOf</h2><p><code>Object.prototype.isPrototypeOf()</code>返回一个布尔值，表示指定的对象是否在本对象的原型链中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Dogs);</span><br><span class=\"line\">Dogs.prototype.isPrototypeOf(sijing);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3-getPrototypeOf\"><a href=\"#6-3-getPrototypeOf\" class=\"headerlink\" title=\"6.3 getPrototypeOf\"></a>6.3 getPrototypeOf</h2><p><code>Object.getPrototypeOf</code>返回该对象的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">11</span>);</span><br><span class=\"line\">sijing.__proto__ === <span class=\"built_in\">Object</span>.getPrototypeOf(sijing)</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、ES5-对象继承\"><a href=\"#七、ES5-对象继承\" class=\"headerlink\" title=\"七、ES5 对象继承\"></a>七、ES5 对象继承</h1><h2 id=\"7-1-原型继承\"><a href=\"#7-1-原型继承\" class=\"headerlink\" title=\"7.1 原型继承\"></a>7.1 原型继承</h2><p>原型继承就是利用<strong> 原型链 </strong>来实现继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.supername = <span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperName= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.supername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subname=<span class=\"string\">'subname'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSubName());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSuperName());</span><br></pre></td></tr></table></figure>\n<p>需要注意的地方：<br>实现原型继承的时候不要使用对象字面量创建原型方法，因为这样做，会重写原型链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.supername = <span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperName= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.supername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subname=<span class=\"string\">'subname'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype =  &#123;</span><br><span class=\"line\">  getSubName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSubName());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSuperName()); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>上面使用<code>SubType.prototype = {...}</code>之后，<code>SubType</code>的原型就是<code>Object</code>了，而不是<code>SuperType</code>了。</p>\n<p>优点：原型定义的属性和方法可以复用<br>缺点：</p>\n<ol>\n<li>引用类型的原型属性会被所有实例共享 </li>\n<li>创建子对象时，不能向父对象的构造函数中传递参数</li>\n</ol>\n<h2 id=\"7-2-构造函数继承\"><a href=\"#7-2-构造函数继承\" class=\"headerlink\" title=\"7.2 构造函数继承\"></a>7.2 构造函数继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName() <span class=\"comment\">// window</span></span><br><span class=\"line\">getName.call(a) <span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n<p>执行<code>getName()</code>时，函数体的<code>this</code>指向<code>window</code>，而执行<code>getName.call(a)</code>时，函数体的<code>this</code>指向的是<code>a</code>对象，所以就可以理解啦。接下来我们看如何实现构造函数继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承SuperType</span></span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">'blue'</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">// red, green, blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors); <span class=\"comment\">// red, green</span></span><br></pre></td></tr></table></figure>\n<p><code>SuperType.call(this)</code>这一行代码，实际上意思是在<code>SubType</code>的实例初始化过程中，调用了<code>SuperType</code>的构造函数，因此<code>SubType</code>的每个实例都有<code>colors</code>这个属性</p>\n<p>优点：子对象可以传递参数给父对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  name = name || <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'scofield'</span>, <span class=\"number\">28</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.name); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.age); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的地方是在调用父对象的构造函数之后，再给子类型中的定义属性，否则会被重写。</p>\n<p>缺点：方法都需要在构造函数中定义，难以做到函数的复用，而且在父对象的原型上定义的方法，对于子类型是不可见的。 ??? 为什么不可见</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.prefix = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'prefix'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'scofield'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.prefix);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// Uncaught TypeError: instance1.getName is not a function</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-3-组合式继承\"><a href=\"#7-3-组合式继承\" class=\"headerlink\" title=\"7.3 组合式继承\"></a>7.3 组合式继承</h2><p><strong>组合式继承</strong> 顾名思义，就是组合两种模式实现JavaScript的继承，借助 <strong>原型链</strong> 和 <strong>构造函数</strong> 来实现。这样子在原型上定义方法实现了函数的复用，而且能够保证每个实例都有自己的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.con = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'li'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">instance1.con.push(<span class=\"string\">'test1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.con); <span class=\"comment\">// test1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getAge()); <span class=\"comment\">// 18</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// li</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'hang'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.con); <span class=\"comment\">// test1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getAge()); <span class=\"comment\">// 18</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// hang</span></span><br></pre></td></tr></table></figure>\n<p>优点：弥补了 <strong>原型继承</strong> 和 <strong>构造函数</strong> 的缺点<br>缺点：父类构造函数调用了两次</p>\n<h2 id=\"7-4-原型式继承\"><a href=\"#7-4-原型式继承\" class=\"headerlink\" title=\"7.4 原型式继承\"></a>7.4 原型式继承</h2><p>原型式继承并没有使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newOrient</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  newOrient.prototype = o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newOrient();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说<code>createObject</code>函数，对传入的<code>o</code>对象进行的一次浅拷贝。在ES5中新增加了一个方法<code>Object.create()</code>, 它的作用和<code>createObject</code>是一样的，但是只支持IE9+。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Dogs = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jingmao'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BigDogs = <span class=\"built_in\">Object</span>.create(Dogs);</span><br><span class=\"line\">BigDogs.name= <span class=\"string\">'bigjingmao'</span>;</span><br><span class=\"line\">BigDogs.size = <span class=\"string\">'big'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(BigDogs.age);</span><br></pre></td></tr></table></figure>\n<p>其中<code>Object.create</code>还支持传入第二个参数，参数与<code>Object.defineProperties()</code>方法的格式相同，并且会覆盖原型上的同名属性。</p>\n<h2 id=\"7-5-寄生式继承\"><a href=\"#7-5-寄生式继承\" class=\"headerlink\" title=\"7.5 寄生式继承\"></a>7.5 寄生式继承</h2><p><strong>寄生式继承</strong> 其实和 <strong>原型式继承</strong> 很类似，区别在于，<strong>寄生式继承</strong> 创建的一个函数把所有的事情做完了，例如给新的对象增加属性和方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = <span class=\"built_in\">Object</span>.create(o);</span><br><span class=\"line\">  clone.size = <span class=\"string\">'big'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Dogs = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jingmao'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BigDogs = createAnother(Dogs);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(BigDogs.size);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6-寄生组合式继承\"><a href=\"#7-6-寄生组合式继承\" class=\"headerlink\" title=\"7.6 寄生组合式继承\"></a>7.6 寄生组合式继承</h2><p>到最后一个了，看看我们之前遗留的问题:<br><strong>组合继承</strong> 会调用两次父对象的构造函数，并且父类型的属性存在两组，一组在实例上，一组在SubType的原型上。解决这个问题的方法就是 <strong>寄生组合式继承</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 继承父类的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(superType.prototype);</span><br><span class=\"line\">  <span class=\"comment\">// 重写被污染的construct</span></span><br><span class=\"line\">  prototype.constructor = subType; </span><br><span class=\"line\">  <span class=\"comment\">// 重写子类的原型  </span></span><br><span class=\"line\">  subType.prototype = prototype; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数就是 <strong>寄生组合式继承</strong> 的最简单的实现方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'hello'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.__proto__.constructor == SubType</span><br></pre></td></tr></table></figure>\n<p>可以看到</p>\n<ol>\n<li>子类继承了父类的属性和方法，同时属性没有创建在原型链上，因此多个子类不会共享同一个属性。</li>\n<li>子类可以动态传递参数给父类</li>\n<li>父类构造函数只执行了一次</li>\n</ol>\n<p>但是还有一个问题：<br>子类如果在原型上添加方法，必须要在继承之后添加，否则会覆盖原来原型上的方法。但是如果这两个类是已存在的类，就不行了</p>\n<p>优化一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 继承父类的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(superType.prototype);</span><br><span class=\"line\">  <span class=\"comment\">// 重写被污染的construct</span></span><br><span class=\"line\">  prototype.constructor = subType; </span><br><span class=\"line\">  <span class=\"comment\">// 重写子类的原型  </span></span><br><span class=\"line\">  subType.prototype = <span class=\"built_in\">Object</span>.assign(prototype, subType.prototype); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然通过<code>Object.assign</code>来进行<code>copy</code>解决了覆盖原型类型的方法的问题，但是<code>Object.assign</code>只能够拷贝可枚举的方法，而且如果子类本身就继承了一个类，这个办法也不行。</p>\n<h1 id=\"八、ES6-实现继承\"><a href=\"#八、ES6-实现继承\" class=\"headerlink\" title=\"八、ES6 实现继承\"></a>八、ES6 实现继承</h1><p>我们知道了ES5中可以通过原型链来实现继承，ES6提供了extends关键字来实现继承，这相对而言更加清晰和方便，首先看看ES6 Class的语法，此处参考<a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/class</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>JavaScript面向对象程序设计</strong><br>本文会碰到的知识点：<br>原型、原型链、函数对象、普通对象、继承</p>\n<p>读完本文，可以学到</p>\n<ul>\n<li>面向对象的基本概念</li>\n<li>JavaScript对象属性</li>\n<li>理解JavaScript中的函数对象与普通对象</li>\n<li>理解<code>prototype</code>和<code>proto</code></li>\n<li>理解原型和原型链</li>\n<li>详解原型链相关的Object方法</li>\n<li>了解如何用ES5模拟类，以及各种方式的优缺点</li>\n<li>了解如何用ES6实现面向对象</li>\n</ul>\n<h1 id=\"一、面向对象的基本概念\"><a href=\"#一、面向对象的基本概念\" class=\"headerlink\" title=\"一、面向对象的基本概念\"></a>一、面向对象的基本概念</h1><p>面向对象也即是OOP，Object Oriented Programming，是计算机的一种编程架构，OOP的基本原则是计算机是由子程序作用的单个或者多个对象组合而成，包含属性和方法的对象是类的实例，但是JavaScript中没有类的概念，而是直接使用对象来实现编程。<br>特性：</p>\n<ul>\n<li>封装：能够将一个实体的信息、功能、响应都封装到一个单独对象中的特性。</li>\n</ul>\n<p>由于JavaScript没有<code>public</code>、<code>private</code>、<code>protected</code>这些关键字，但是可以利用变量的作用域来模拟public和private封装特性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> insObject = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _name = <span class=\"string\">'hello'</span>; <span class=\"comment\">// private</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// public</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> _name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">insObject._name; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">insObject.getName(); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n<p>这里只是实现了一个简单的版本，private比较好的实现方式可以参考深入理解<code>ES6 145页</code>,protected可以利用ES6的Symbol关键字来实现，这里不展开，有兴趣可以讨论</p>\n<p><strong>继承</strong>：在不改变源程序的基础上进行扩充，原功能得以保存，并且对子程序进行扩展，避免重复代码编写，后面的章节详细描述</p>\n<h1 id=\"二、JavaScript对象属性\"><a href=\"#二、JavaScript对象属性\" class=\"headerlink\" title=\"二、JavaScript对象属性\"></a>二、JavaScript对象属性</h1><p>想弄懂面向对象，是不是先看看对象是啥呢？<br>我们先看一个题目:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] + &#123;&#125;; <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\">&#123;&#125; + []; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<p>解释：<br>在第一行中，<code>{}</code>出现在<code>+</code>操作符的表达式中，因此被翻译为一个实际的值（一个空<code>object</code>）。而<code>[]</code>被强制转换为””,因此<code>{}</code>也会被强制转换为一个<code>string:&quot;[object Object]&quot;</code>。<br>但在第二行中，<code>{}</code>被翻译为一个独立的<code>{}</code>空代码块儿（它什么也不做）。块儿不需要分号来终结它们，所以这里缺少分号不是一个问题。最终，<code>+ []</code>是一个将<code>[]</code>明确强制转换 为<code>number</code>的表达式，而它的值是<code>0</code>。</p>\n<h2 id=\"2-1-属性\"><a href=\"#2-1-属性\" class=\"headerlink\" title=\"2.1 属性\"></a>2.1 属性</h2><p><em>对象的属性</em></p>\n<ul>\n<li><code>Object.prototype</code> Object 的原型对象，不是每个对象都有<code>prototype</code>属性</li>\n<li><code>Object.prototype.proto</code> 不是标准方法，不鼓励使用，每个对象都有<code>proto</code>属性，但是由于浏览器实现方式的不同，<code>proto</code>属性在chrome、firefox中实现了，在IE中并不支持，替代的方法是<code>Object.getPrototypeOf()</code></li>\n<li><code>Object.prototype.constructor</code>：用于创建一个对象的原型，创建对象的构造函数</li>\n</ul>\n<p>可能大家会有一个疑问，为什么上面那些属性要加上<code>prototype</code><br>在chrome中打印一下<code>var a = { test: &#39;test&#39; }</code></p>\n<p><em>属性描述符</em><br>数据属性：</p>\n<table>\n<thead>\n<tr>\n<th>特性名称</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>属性的值</td>\n<td>undfined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>是否可以修改属性的值，true表示可以，false表示不可以</td>\n<td>true</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>属性值是否可枚举，true表示可枚举for-in, false表示不可枚举</td>\n<td>true</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>属性的特性是否可配置，表示能否通过delete删除属性后重新定义属性</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>例子:<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"//sml-myoss.oss-cn-beijing.aliyuncs.com/blog/word_img/20180702231814.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure></p>\n<p>访问器属性：</p>\n<table>\n<thead>\n<tr>\n<th>特性名称</th>\n<th>描述</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>set</td>\n<td>设置属性时调用的函数</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>写入属性时调用的函数</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>表示能否通过delete删除属性后重新定义属性</td>\n<td>true</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>表示能否通过for-in循环返回属性</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>访问器属性不能直接定义，一般是通过<code>Object.defineProperty()</code>方法来定义，但是这个方法只支持IE9+， 以前一般用两个非标准方法来实现<code>__defineGetter__()</code>和֖<code>__defineSetter__()</code></p>\n<p>例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> book = &#123; <span class=\"attr\">_year</span>: <span class=\"number\">2004</span>, <span class=\"attr\">edition</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(book, <span class=\"string\">\"year\"</span>, &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._year;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newValue &gt; <span class=\"number\">2004</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._year = newValue;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.edition += newValue - <span class=\"number\">2004</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = <span class=\"number\">2005</span>; </span><br><span class=\"line\">alert(book.edition);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2-方法\"><a href=\"#2-2-方法\" class=\"headerlink\" title=\"2.2 方法\"></a>2.2 方法</h2><ul>\n<li><code>Object.prototype.toString()</code> 返回对象的字符串表示</li>\n<li><code>Object.prototype.hasOwnProperty()</code> 返回一个布尔值，表示某个对象是否含有指定的属性，而且此属性非原型链继承，也就是说不会检查原型链上的属性</li>\n<li><code>Object.prototype.isPrototypeOf()</code> 返回一个布尔值，表示指定的对象是否在本对象的原型链中</li>\n<li><code>Object.prototype.propertyIsEnumerable()</code> 判断指定属性是否可枚举</li>\n<li><code>Object.prototype.watch()</code> 给对象的某个属性增加监听</li>\n<li><code>Object.prototype.unwatch()</code> 移除对象某个属性的监听</li>\n<li><code>Object.prototype.valueOf()</code> 返回指定对象的原始值</li>\n<li>获取和设置属性<ul>\n<li><code>Object.defineProperty</code> 定义单个属性</li>\n<li><code>Object.defineProperties</code> 定义多个属性</li>\n<li><code>Object.getOwnPropertyDescriptor</code> 获取属性</li>\n</ul>\n</li>\n<li><code>Object.assign()</code> 拷贝可枚举属性 （ES6新增）</li>\n<li><code>Object.create()</code> 创建对象</li>\n<li><code>Object.entries()</code> 返回一个包含由给定对象所有可枚举属性的属性名和属性值组成的 [属性名，属性值] 键值对的数组，数组中键值对的排列顺序和使用for…in循环遍历该对象时返回的顺序一致</li>\n<li><code>Object.freeze()</code> 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象</li>\n<li><code>Object.getOwnPropertyNames()</code> 返回指定对象的属性名组成的数组</li>\n<li><code>Object.getPrototypeOf</code> 返回该对象的原型</li>\n<li><code>Object.is(value1, value2)</code> 判断两个值是否是同一个值 (ES6 新增)</li>\n<li><code>Object.keys()</code> 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致</li>\n<li><code>Object.setPrototypeOf(obj, prototype)</code> 将一个指定的对象的原型设置为另一个对象或者null</li>\n<li><code>Object.values</code> 返回一个包含指定对象所有的可枚举属性值的数组，数组中的值顺序和使用for…in循环遍历的顺序一样</li>\n</ul>\n<h2 id=\"2-3-应用\"><a href=\"#2-3-应用\" class=\"headerlink\" title=\"2.3 应用\"></a>2.3 应用</h2><p>如何检测某个属性是否在对象中？</p>\n<ul>\n<li>in运算符，判断对象是否包含某个属性，会从对象的实例属性、继承属性里进行检测</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dogs</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BigDogs</span>(<span class=\"params\">size</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BigDogs.prototype = <span class=\"keyword\">new</span> Dogs();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> BigDogs(<span class=\"string\">'big'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'size'</span> <span class=\"keyword\">in</span> a;</span><br><span class=\"line\"><span class=\"string\">'name'</span> <span class=\"keyword\">in</span> a;</span><br><span class=\"line\"><span class=\"string\">'age'</span> <span class=\"keyword\">in</span> a;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Object.hasOwnProperty()，判断一个对象是否有指定名称的属性，不会检查继承属性</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'size'</span>);</span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'name'</span>);</span><br><span class=\"line\">a.hasOwnProperty(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.propertyIsEnumerable()</code>，判断指定名称的属性是否为实例属性并且是可枚举的</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;&#125;, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(b, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">a.propertyIsEnumerable(<span class=\"string\">'name'</span>);</span><br><span class=\"line\">a.propertyIsEnumerable(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何枚举对象的属性，并保证不同了浏览器中的行为是一致的？</li>\n</ul>\n<p><code>for/in</code> 语句，可以遍历可枚举的实例属性和继承属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  supername: <span class=\"string\">'super hello'</span>,</span><br><span class=\"line\">  superage: <span class=\"string\">'super name'</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(b, &#123;</span><br><span class=\"line\">  name: &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">11</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(b, a); <span class=\"comment\">// 设置b的原型是a 等效的是b.__proto__ = a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(pro <span class=\"keyword\">in</span> b) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pro); <span class=\"comment\">// name, supername, superage</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.keys()</code>， 返回一个数组，内容是对象可枚举的实例属性名称</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> propertyArray = <span class=\"built_in\">Object</span>.keys(b); <span class=\"comment\">// name</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Object.getOwnPropertyNames()</code>，返回一个数组，内容是对象所有实例属性，包括可枚举和不可枚举</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> propertyArray = <span class=\"built_in\">Object</span>.getOwnPropertyNames(b); <span class=\"comment\">// name, age</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>如何判断两个对象是否相等？</li>\n</ul>\n<p>我只想说，这个问题说简单很简单，说复杂也挺复杂的<a href=\"https://stackoverflow.com/questions/1068834/object-comparison-in-javascript\" target=\"_blank\" rel=\"noopener\">传送门</a><br>我们看个简单版的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isEquivalent</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> aProps = <span class=\"built_in\">Object</span>.getOwnPropertyNames(a);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bProps = <span class=\"built_in\">Object</span>.getOwnPropertyNames(b);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (aProps.length != bProps.length)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; aProps.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> propName = aProps[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[propName] !== b[propName]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Outputs: true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isEquivalent(&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;,&#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;));</span><br></pre></td></tr></table></figure>\n<p>上面这个函数还有啥问题呢</p>\n<ul>\n<li>没有对传入参数进行校验，例如判断是否是NaN，或者是其他内置属性</li>\n<li>没有判断传入对象的construct和prototype</li>\n<li>时间算法复杂度是O(n2)</li>\n</ul>\n<p>有同学可能会有疑问，能不能用<code>Object.is</code>，答案是否定的，<code>Object.is</code>简单来说就是在<code>===</code>的基础上特别处理了<code>NaN</code>，<code>+0</code>，<code>-0</code>，保证了<code>-0</code>和<code>+0</code>不相同，<code>Object.is(NaN, NaN)</code>返回<code>true</code>。</p>\n<ul>\n<li>对象的深拷贝和浅拷贝</li>\n</ul>\n<p>其实如果大家理解了上面的那些方法，是很容易写出深拷贝和浅拷贝的代码的，我们先看一下这两者的却别。<br>浅拷贝仅仅是复制引用，拷贝后<code>a === b</code>， 注意<code>Object.assign</code>方法实现的是浅复制（此处有深刻教训！！！）<br>深拷贝这是创建了一个新的对象，然后把旧的对象中的属性和方法拷贝到新的对象中，拷贝后 <code>a !== b</code><br>深拷贝的实现由很多例子，例如<code>jQuery</code>的<code>extend</code>和<code>lodash中的cloneDeep</code>, clone。jQuery可以使用<code>$.extend(true, {}, ...)</code>来实现深拷贝, 但是jQuery无法复制JSON对象之外的对象，例如ES6引入的<code>Map</code>、<code>Set</code>等。而lodash加入的大量的代码来实现ES6新引入的标准对象</p>\n<h1 id=\"三、对象分为函数对象和普通对象\"><a href=\"#三、对象分为函数对象和普通对象\" class=\"headerlink\" title=\"三、对象分为函数对象和普通对象\"></a>三、对象分为函数对象和普通对象</h1><p><strong> 什么是函数对象和普通对象？</strong><br><code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>等js的内置对象都是函数对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a1</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> c1 = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> c2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> d1 = <span class=\"keyword\">new</span> a1();</span><br><span class=\"line\"><span class=\"keyword\">const</span> d2 = <span class=\"keyword\">new</span> b1(); <span class=\"comment\">// ????</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> d3 = <span class=\"keyword\">new</span> c1(); <span class=\"comment\">// ????</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a2;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c1;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> c2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> d1;</span><br></pre></td></tr></table></figure>\n<p>上面两行报错的原因，是因为构造函数只能由函数来充当，而b1和c1不是Function的实例，所以不能充当构造器<br><strong> 但是只有Function的实例都是函数对象、其他的实例都是普通对象 </strong><br>我们延伸一下，在看个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> e1 = <span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> e2 = <span class=\"keyword\">new</span> e1();</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: e1 is not a constructor</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e1.constructor) <span class=\"comment\">// 是有值的。。。</span></span><br><span class=\"line\"><span class=\"comment\">// 规范里面就不能new</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> e2 = e1();</span><br></pre></td></tr></table></figure>\n<p><code>GeneratorFunction</code>是一个特殊的函数对象<br><code>e1.__proto__.__proto__ === Function.prototype</code></p>\n<p><code>e1</code>的原型实际上是一个生成器函数<code>GeneratorFunction</code>，也就是说<br><code>e1.__proto__ === GeneratorFunction.prototype</code></p>\n<p>这行代码有问题么，啊哈哈哈，<code>GeneratorFunction</code>这个关键字主流的JavaScript还木有暴露出来，所以这个大家理解就好啦</p>\n<p>虽然不能直接<code>new e1</code><br>但是可以<code>new e1.constructor();</code>哈哈哈哈</p>\n<h1 id=\"四、理解prototype和proto\"><a href=\"#四、理解prototype和proto\" class=\"headerlink\" title=\"四、理解prototype和proto\"></a>四、理解prototype和proto</h1><table>\n<thead>\n<tr>\n<th>对象类型</th>\n<th>prototype</th>\n<th>proto</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>函数对象</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>普通对象</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>只有函数对象具有<code>prototype</code>这个属性</li>\n<li><code>prototype</code>和<code>__proto__</code>都是js在定义一个对象时的预定义属性</li>\n<li><code>prototype</code>是被实例的<code>__proto__</code>指向</li>\n<li><code>__proto__</code>指向构造函数的<code>prototype</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">// object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a.prototype <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a.__proto__ <span class=\"comment\">// function</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b.prototype <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b.__proto__ <span class=\"comment\">// object</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n<p>理解了<code>prototype</code>和<code>__proto__</code>之后，我们来看看之前一直说的为什么JavaScript里面都是对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> c = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">a.__proto__</span><br><span class=\"line\">a.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">b.__proto__</span><br><span class=\"line\">b.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">c.__proto__</span><br><span class=\"line\">c.__proto__ === <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">d.__proto__</span><br><span class=\"line\">d.__proto__ === <span class=\"built_in\">Date</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ <span class=\"comment\">//null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype</span><br></pre></td></tr></table></figure>\n<p>延伸一个问题：如何判断一个变量是否是数组？</p>\n<ul>\n<li>typeof</li>\n</ul>\n<p>我们上面已经解释了，这些都是普通对象，普通对象是没有<code>prototype</code>的，他们<code>typeof</code>的值都是<code>object</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> []</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>从原型来看, 原理就是看Array是否在a的原型链中<br>a的原型链是 Array-&gt;Object</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.isPrototypeOf(obj);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>instanceof</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span></span><br></pre></td></tr></table></figure>\n<p>从构造函数入手，但是这个方法和上面的方法都有一问题，不同的框架中创建的数组不会相互共享其<code>prototype</code>属性<br>根据对象的class属性，跨原型调用<code>tostring</code>方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(a);</span><br><span class=\"line\"><span class=\"comment\">// [Object Array]</span></span><br></pre></td></tr></table></figure>\n<p>ES5 中所有内置对象的[[Class]]属性的值是由规范定义的，但是 ES6 中已经没有了[[Class]]属性，取代它的是[[NativeBrand]]属性，这个大家有兴趣可以自行去查看规范<br>原理：</p>\n<ol>\n<li>如果<code>this</code>的值为<code>undefined</code>,则返回<code>&#39;[object Undefined]&#39;</code>. </li>\n<li>如果<code>this</code>的值为<code>null</code>,则返回<code>[object Null]</code>. </li>\n<li>让<code>O</code>成为调用<code>ToObject(this)</code>的结果. </li>\n<li>让<code>class</code>成为<code>O</code>的内部属性<code>[[Class]]</code>的值. </li>\n<li>返回三个字符串<code>&#39;[object &#39;</code>, <code>&#39;class&#39;</code>, 以及 <code>&#39;]&#39;</code>连接后的新字符串.</li>\n</ol>\n<p>问题？这个一定是正确的么？不正确为啥？<br>提示ES6的<code>Symbol</code>属性<br><code>Array.isArray()</code><br>部分浏览器中不兼容</p>\n<h1 id=\"五、理解原型与原型链\"><a href=\"#五、理解原型与原型链\" class=\"headerlink\" title=\"五、理解原型与原型链\"></a>五、理解原型与原型链</h1><p>其实上一节中的<code>prototype</code>和<code>proto</code>就是为了构建原型链而存在的，之前也或多或少的说到了原型链这个概念。</p>\n<p>看下面的代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"string\">'sijing'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sijing);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sijing.getName());</span><br></pre></td></tr></table></figure>\n<p>这段代码的执行过程</p>\n<ol>\n<li>首先创建了一个构造函数<code>Dogs</code>，传入一个参数<code>name</code>，<code>Dogs.prototype</code>也会自动创建</li>\n<li>给对象<code>dogs</code>增加了一个方法 </li>\n<li>通过构造函数<code>Dogs</code>实例化了一个对象<code>sijing</code></li>\n<li>输出<code>sijing</code>的值,可以看到<code>sijing</code>有两个值<code>name</code>和<code>proto</code>,其中<code>proto</code>指向<code>Dogs.prototype</code></li>\n<li>执行<code>getName</code>方法时，在<code>sijing</code>中找不到这个方法，就会继续向着原型链继续往上找，也就是通过<code>proto</code>，然后就找到了<code>getName</code>方法。</li>\n</ol>\n<p>这个过程实际上就是原型继承，实际上JavaScript的原型继承就是利用了<code>proto</code>并借助<code>prototype</code>来实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sijing.__proto__ === <span class=\"built_in\">Function</span>.prototype</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype <span class=\"comment\">// 指向什么</span></span><br><span class=\"line\">Dogs.prototype.__proto__ <span class=\"comment\">// 指向什么</span></span><br><span class=\"line\">Dogs.prototype.__proto__.__proto__ <span class=\"comment\">// 指向什么</span></span><br></pre></td></tr></table></figure>\n<p>上面例子中<code>getName</code>最终是查找到了，那么如果在原型链中一直没查找到，会怎么样？<br>例如<code>console.log(sijing.age)</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sijing <span class=\"comment\">// 是一个对象可以继续</span></span><br><span class=\"line\">sijing.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__ <span class=\"comment\">// 是一个对象可以继续</span></span><br><span class=\"line\">sijing.__proto__.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__ <span class=\"comment\">// 是个对象可以继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__.age <span class=\"comment\">// 不存在，继续</span></span><br><span class=\"line\">sijing.__proto__.__proto__.__proto__ <span class=\"literal\">null</span>，<span class=\"comment\">// 不是对象，到头啦</span></span><br></pre></td></tr></table></figure>\n<p><strong>原型链</strong> 的概念其实不重要，重要的是要理解，简单来说，原型链就是利用原型让一个引用类型继承另一个应用类型的属性和方法。</p>\n<p>还有三点需要注意的:</p>\n<ul>\n<li>任何内置函数对象（类）本身的 <code>_proto_</code>都指向<code>Function</code>的原型对象；</li>\n<li>除了<code>Object</code>的原型对象的<code>_proto_</code>指向<code>null</code>，其他所有内置函数对象的原型对象的<code>_proto_</code>都指向<code>object</code>。</li>\n<li>所有构造函数的的<code>prototype</code>方法的<code>proto</code>都指向<code>Object.prototype</code>（除了….<code>Object.prototype</code>自身）</li>\n</ul>\n<p>如果理解了上面这些内容，大家可以自行描述一下，构造函数、原型和实例之间的关系.</p>\n<ul>\n<li>构造函数首字母必须大写，用来区分普通函数，内部使用<code>this</code>指针，指向要生成的实例对象，通过<code>new</code>来生成实例对象。 </li>\n<li>实例就是通过<code>new</code>一个构造函数产生的对象，它有一个属性<code>[[prototype]]</code>指向原型 </li>\n<li>原型中有一个属性<code>[[constructor]]</code>，指向构造函数</li>\n</ul>\n<h1 id=\"六、与原型链相关的方法\"><a href=\"#六、与原型链相关的方法\" class=\"headerlink\" title=\"六、与原型链相关的方法\"></a>六、与原型链相关的方法</h1><h2 id=\"6-1-hasOwnProperty\"><a href=\"#6-1-hasOwnProperty\" class=\"headerlink\" title=\"6.1 hasOwnProperty\"></a>6.1 hasOwnProperty</h2><p><code>Object.hasOwnProperty()</code>返回一个布尔值，表示某个对象的实例是否含有指定的属性，而且此属性非原型链继承。用来判断属性是来自实例属性还是原型属性。类似还有<code>in</code>操作符，<code>in</code>操作符只要属性存在，不管实在实例中还是原型中，就会返回<code>true</code>。同时使用<code>in</code>和<code>hasOwnProperty</code>就可以判断属性是在原型中还是在实例中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">14</span>);</span><br><span class=\"line\">sijing.hasOwnProperty(<span class=\"string\">'age'</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2-isPrototypeOf\"><a href=\"#6-2-isPrototypeOf\" class=\"headerlink\" title=\"6.2 isPrototypeOf\"></a>6.2 isPrototypeOf</h2><p><code>Object.prototype.isPrototypeOf()</code>返回一个布尔值，表示指定的对象是否在本对象的原型链中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(Dogs);</span><br><span class=\"line\">Dogs.prototype.isPrototypeOf(sijing);</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3-getPrototypeOf\"><a href=\"#6-3-getPrototypeOf\" class=\"headerlink\" title=\"6.3 getPrototypeOf\"></a>6.3 getPrototypeOf</h2><p><code>Object.getPrototypeOf</code>返回该对象的原型</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Dogs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dogs.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sijing = <span class=\"keyword\">new</span> Dogs(<span class=\"number\">11</span>);</span><br><span class=\"line\">sijing.__proto__ === <span class=\"built_in\">Object</span>.getPrototypeOf(sijing)</span><br></pre></td></tr></table></figure>\n<h1 id=\"七、ES5-对象继承\"><a href=\"#七、ES5-对象继承\" class=\"headerlink\" title=\"七、ES5 对象继承\"></a>七、ES5 对象继承</h1><h2 id=\"7-1-原型继承\"><a href=\"#7-1-原型继承\" class=\"headerlink\" title=\"7.1 原型继承\"></a>7.1 原型继承</h2><p>原型继承就是利用<strong> 原型链 </strong>来实现继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.supername = <span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperName= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.supername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subname=<span class=\"string\">'subname'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subname;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSubName());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSuperName());</span><br></pre></td></tr></table></figure>\n<p>需要注意的地方：<br>实现原型继承的时候不要使用对象字面量创建原型方法，因为这样做，会重写原型链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.supername = <span class=\"string\">'super'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getSuperName= <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.supername;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subname=<span class=\"string\">'subname'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype =  &#123;</span><br><span class=\"line\">  getSubName: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subname;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSubName());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getSuperName()); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<p>上面使用<code>SubType.prototype = {...}</code>之后，<code>SubType</code>的原型就是<code>Object</code>了，而不是<code>SuperType</code>了。</p>\n<p>优点：原型定义的属性和方法可以复用<br>缺点：</p>\n<ol>\n<li>引用类型的原型属性会被所有实例共享 </li>\n<li>创建子对象时，不能向父对象的构造函数中传递参数</li>\n</ol>\n<h2 id=\"7-2-构造函数继承\"><a href=\"#7-2-构造函数继承\" class=\"headerlink\" title=\"7.2 构造函数继承\"></a>7.2 构造函数继承</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'window'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getName() <span class=\"comment\">// window</span></span><br><span class=\"line\">getName.call(a) <span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n<p>执行<code>getName()</code>时，函数体的<code>this</code>指向<code>window</code>，而执行<code>getName.call(a)</code>时，函数体的<code>this</code>指向的是<code>a</code>对象，所以就可以理解啦。接下来我们看如何实现构造函数继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 继承SuperType</span></span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">'blue'</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">// red, green, blue</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors); <span class=\"comment\">// red, green</span></span><br></pre></td></tr></table></figure>\n<p><code>SuperType.call(this)</code>这一行代码，实际上意思是在<code>SubType</code>的实例初始化过程中，调用了<code>SuperType</code>的构造函数，因此<code>SubType</code>的每个实例都有<code>colors</code>这个属性</p>\n<p>优点：子对象可以传递参数给父对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  name = name || <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'scofield'</span>, <span class=\"number\">28</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.name); <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.age); <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的地方是在调用父对象的构造函数之后，再给子类型中的定义属性，否则会被重写。</p>\n<p>缺点：方法都需要在构造函数中定义，难以做到函数的复用，而且在父对象的原型上定义的方法，对于子类型是不可见的。 ??? 为什么不可见</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.prefix = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'prefix'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'scofield'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.prefix);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// Uncaught TypeError: instance1.getName is not a function</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-3-组合式继承\"><a href=\"#7-3-组合式继承\" class=\"headerlink\" title=\"7.3 组合式继承\"></a>7.3 组合式继承</h2><p><strong>组合式继承</strong> 顾名思义，就是组合两种模式实现JavaScript的继承，借助 <strong>原型链</strong> 和 <strong>构造函数</strong> 来实现。这样子在原型上定义方法实现了函数的复用，而且能够保证每个实例都有自己的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.con = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\">SubType.prototype.constructor = SubType;</span><br><span class=\"line\">SubType.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'li'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">instance1.con.push(<span class=\"string\">'test1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.con); <span class=\"comment\">// test1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getAge()); <span class=\"comment\">// 18</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// li</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'hang'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.con); <span class=\"comment\">// test1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getAge()); <span class=\"comment\">// 18</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.getName()); <span class=\"comment\">// hang</span></span><br></pre></td></tr></table></figure>\n<p>优点：弥补了 <strong>原型继承</strong> 和 <strong>构造函数</strong> 的缺点<br>缺点：父类构造函数调用了两次</p>\n<h2 id=\"7-4-原型式继承\"><a href=\"#7-4-原型式继承\" class=\"headerlink\" title=\"7.4 原型式继承\"></a>7.4 原型式继承</h2><p>原型式继承并没有使用严格意义上的构造函数，借助原型可以基于已有的对象创建新的对象，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObject</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newOrient</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  newOrient.prototype = o;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newOrient();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单来说<code>createObject</code>函数，对传入的<code>o</code>对象进行的一次浅拷贝。在ES5中新增加了一个方法<code>Object.create()</code>, 它的作用和<code>createObject</code>是一样的，但是只支持IE9+。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Dogs = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jingmao'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BigDogs = <span class=\"built_in\">Object</span>.create(Dogs);</span><br><span class=\"line\">BigDogs.name= <span class=\"string\">'bigjingmao'</span>;</span><br><span class=\"line\">BigDogs.size = <span class=\"string\">'big'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(BigDogs.age);</span><br></pre></td></tr></table></figure>\n<p>其中<code>Object.create</code>还支持传入第二个参数，参数与<code>Object.defineProperties()</code>方法的格式相同，并且会覆盖原型上的同名属性。</p>\n<h2 id=\"7-5-寄生式继承\"><a href=\"#7-5-寄生式继承\" class=\"headerlink\" title=\"7.5 寄生式继承\"></a>7.5 寄生式继承</h2><p><strong>寄生式继承</strong> 其实和 <strong>原型式继承</strong> 很类似，区别在于，<strong>寄生式继承</strong> 创建的一个函数把所有的事情做完了，例如给新的对象增加属性和方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createAnother</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = <span class=\"built_in\">Object</span>.create(o);</span><br><span class=\"line\">  clone.size = <span class=\"string\">'big'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Dogs = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jingmao'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> BigDogs = createAnother(Dogs);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(BigDogs.size);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6-寄生组合式继承\"><a href=\"#7-6-寄生组合式继承\" class=\"headerlink\" title=\"7.6 寄生组合式继承\"></a>7.6 寄生组合式继承</h2><p>到最后一个了，看看我们之前遗留的问题:<br><strong>组合继承</strong> 会调用两次父对象的构造函数，并且父类型的属性存在两组，一组在实例上，一组在SubType的原型上。解决这个问题的方法就是 <strong>寄生组合式继承</strong>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 继承父类的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(superType.prototype);</span><br><span class=\"line\">  <span class=\"comment\">// 重写被污染的construct</span></span><br><span class=\"line\">  prototype.constructor = subType; </span><br><span class=\"line\">  <span class=\"comment\">// 重写子类的原型  </span></span><br><span class=\"line\">  subType.prototype = prototype; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数就是 <strong>寄生组合式继承</strong> 的最简单的实现方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SuperType.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  SuperType.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inheritPrototype(SubType, SuperType);</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\">  alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType(<span class=\"string\">'hello'</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">instance1.__proto__.constructor == SubType</span><br></pre></td></tr></table></figure>\n<p>可以看到</p>\n<ol>\n<li>子类继承了父类的属性和方法，同时属性没有创建在原型链上，因此多个子类不会共享同一个属性。</li>\n<li>子类可以动态传递参数给父类</li>\n<li>父类构造函数只执行了一次</li>\n</ol>\n<p>但是还有一个问题：<br>子类如果在原型上添加方法，必须要在继承之后添加，否则会覆盖原来原型上的方法。但是如果这两个类是已存在的类，就不行了</p>\n<p>优化一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>)</span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// 继承父类的原型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(superType.prototype);</span><br><span class=\"line\">  <span class=\"comment\">// 重写被污染的construct</span></span><br><span class=\"line\">  prototype.constructor = subType; </span><br><span class=\"line\">  <span class=\"comment\">// 重写子类的原型  </span></span><br><span class=\"line\">  subType.prototype = <span class=\"built_in\">Object</span>.assign(prototype, subType.prototype); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然通过<code>Object.assign</code>来进行<code>copy</code>解决了覆盖原型类型的方法的问题，但是<code>Object.assign</code>只能够拷贝可枚举的方法，而且如果子类本身就继承了一个类，这个办法也不行。</p>\n<h1 id=\"八、ES6-实现继承\"><a href=\"#八、ES6-实现继承\" class=\"headerlink\" title=\"八、ES6 实现继承\"></a>八、ES6 实现继承</h1><p>我们知道了ES5中可以通过原型链来实现继承，ES6提供了extends关键字来实现继承，这相对而言更加清晰和方便，首先看看ES6 Class的语法，此处参考<a href=\"http://es6.ruanyifeng.com/#docs/class\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/class</a></p>\n"},{"title":"JS简单实现防抖和节流","description":"主要针对于时间频繁调用事件而做的性能优化","date":"2018-07-27T09:35:12.000Z","published":1,"_content":"# 一、什么是防抖和节流\n\n**Ps**: 比如搜索框，用户在输入的时候使用`change`事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器资源很强大，也不带这么玩的。\n\n## 1. 防抖 - debounce\n\n其中一种解决方案就是每次用户停止输入后，延迟超过`500ms`时，才去搜索此时的`String`，这就是防抖。\n\n* 原理：将若干个函数调用合成为一次，并在给定时间过去之后仅被调用一次。\n* 代码实现：\n\n```js\nfunction debounce(fn, delay) {\n  // 维护一个 timer，用来记录当前执行函数状态\n  let timer = null;\n\n  return function() {\n    // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量\n    let context = this;\n    let args = arguments;\n    // 清理掉正在执行的函数，并重新执行\n    clearTimeout(timer);\n    timer = setTimeout(function() {\n      fn.apply(context, args);\n    }, delay);\n  }\n}\nlet flag = 0; // 记录当前函数调用次数\n// 当用户滚动时被调用的函数\nfunction foo() {\n  flag++;\n  console.log('Number of calls: %d', flag);\n}\n\n// 在 debounce 中包装我们的函数，过 2 秒触发一次\ndocument.body.addEventListener('scroll', debounce(foo, 2000));\n```\n\n> 1. `debounce`函数封装后，返回内部函数\n> 2. 每一次事件被触发，都会清除当前的`timer`然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发\n> 3. 只有当高频事件停止，最后一次事件触发的超时调用才能在`delay`时间后执行\n\n## 2. 节流 - throttle\n\n另一种解决方案比 *防抖* 要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过`500ms`就查询一次此时的`String`，这就是节流。\n\n* 原理：节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。\n* 代码实现有两种，一种是时间戳，另一种是定时器\n  1）时间戳实现：\n\n```js\nfunction throttle(func, delay){\n  let prev = Date.now();\n  return function(){\n    const context = this;\n    const args    = arguments;\n    const now     = Date.now();\n    if(now - prev >= delay){\n      func.apply(context, args);\n      prev = Date.now();\n    }\n  }\n}\n```\n\n> 当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于`delay`的话），而后再怎么频繁触发事件，也都是会每`delay`秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。\n\n  2）定时器实现：\n  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到`delay`秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。\n\n```js\nfucntion throttle(func, delay){\n  let timer = null;\n\n  return funtion(){\n    let context = this;\n    let args    = arguments;\n    if(!timer){\n      timer = setTimeout(function(){\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  }\n}\n```\n\n> 当第一次触发事件时，肯定不会立即执行函数，而是在`delay`秒后才执行。\n> 之后连续不断触发事件，也会每`delay`秒执行一次。\n> 当最后一次停止触发后，由于定时器的`delay`延迟，可能还会执行一次函数。\n\n  3）综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数\n\n```js\nfunction throttle(func, delay){\n  let timer = null;\n  let startTime = Date.now();\n\n  return function(){\n    let curTime = Date.now();\n    let remaining = delay - (curTime - startTime);\n    const context = this;\n    const args = arguments;\n\n    clearTimeout(timer);\n    if(remaining <= 0){\n      func.apply(context,args);\n      startTime = Date.now();\n    }else{\n      timer = setTimeout(func, remaining);\n    }\n  }\n}\n```\n\n> 需要在每个`delay`时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与`delay`来计算`remaining`，当`remaining <= 0`时表示该执行函数了，如果还没到时间的话就设定在`remaining`时间后再触发。当然在`remaining`这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个`remaining`来判断当前状态。","source":"_posts/js/performance/debounce_throttle.md","raw":"---\ntitle: JS简单实现防抖和节流\ndescription: 主要针对于时间频繁调用事件而做的性能优化\ndate: 2018-07-27 17:35:12\ntags: [ 防抖, 节流 ]\ncategories: [ JS ]\npublished: true\n---\n# 一、什么是防抖和节流\n\n**Ps**: 比如搜索框，用户在输入的时候使用`change`事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器资源很强大，也不带这么玩的。\n\n## 1. 防抖 - debounce\n\n其中一种解决方案就是每次用户停止输入后，延迟超过`500ms`时，才去搜索此时的`String`，这就是防抖。\n\n* 原理：将若干个函数调用合成为一次，并在给定时间过去之后仅被调用一次。\n* 代码实现：\n\n```js\nfunction debounce(fn, delay) {\n  // 维护一个 timer，用来记录当前执行函数状态\n  let timer = null;\n\n  return function() {\n    // 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量\n    let context = this;\n    let args = arguments;\n    // 清理掉正在执行的函数，并重新执行\n    clearTimeout(timer);\n    timer = setTimeout(function() {\n      fn.apply(context, args);\n    }, delay);\n  }\n}\nlet flag = 0; // 记录当前函数调用次数\n// 当用户滚动时被调用的函数\nfunction foo() {\n  flag++;\n  console.log('Number of calls: %d', flag);\n}\n\n// 在 debounce 中包装我们的函数，过 2 秒触发一次\ndocument.body.addEventListener('scroll', debounce(foo, 2000));\n```\n\n> 1. `debounce`函数封装后，返回内部函数\n> 2. 每一次事件被触发，都会清除当前的`timer`然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发\n> 3. 只有当高频事件停止，最后一次事件触发的超时调用才能在`delay`时间后执行\n\n## 2. 节流 - throttle\n\n另一种解决方案比 *防抖* 要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过`500ms`就查询一次此时的`String`，这就是节流。\n\n* 原理：节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。\n* 代码实现有两种，一种是时间戳，另一种是定时器\n  1）时间戳实现：\n\n```js\nfunction throttle(func, delay){\n  let prev = Date.now();\n  return function(){\n    const context = this;\n    const args    = arguments;\n    const now     = Date.now();\n    if(now - prev >= delay){\n      func.apply(context, args);\n      prev = Date.now();\n    }\n  }\n}\n```\n\n> 当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于`delay`的话），而后再怎么频繁触发事件，也都是会每`delay`秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。\n\n  2）定时器实现：\n  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到`delay`秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。\n\n```js\nfucntion throttle(func, delay){\n  let timer = null;\n\n  return funtion(){\n    let context = this;\n    let args    = arguments;\n    if(!timer){\n      timer = setTimeout(function(){\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  }\n}\n```\n\n> 当第一次触发事件时，肯定不会立即执行函数，而是在`delay`秒后才执行。\n> 之后连续不断触发事件，也会每`delay`秒执行一次。\n> 当最后一次停止触发后，由于定时器的`delay`延迟，可能还会执行一次函数。\n\n  3）综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数\n\n```js\nfunction throttle(func, delay){\n  let timer = null;\n  let startTime = Date.now();\n\n  return function(){\n    let curTime = Date.now();\n    let remaining = delay - (curTime - startTime);\n    const context = this;\n    const args = arguments;\n\n    clearTimeout(timer);\n    if(remaining <= 0){\n      func.apply(context,args);\n      startTime = Date.now();\n    }else{\n      timer = setTimeout(func, remaining);\n    }\n  }\n}\n```\n\n> 需要在每个`delay`时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与`delay`来计算`remaining`，当`remaining <= 0`时表示该执行函数了，如果还没到时间的话就设定在`remaining`时间后再触发。当然在`remaining`这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个`remaining`来判断当前状态。","slug":"js/performance/debounce_throttle","updated":"2018-08-01T09:37:33.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjmka46pe000e0qr4y07dobmv","content":"<h1 id=\"一、什么是防抖和节流\"><a href=\"#一、什么是防抖和节流\" class=\"headerlink\" title=\"一、什么是防抖和节流\"></a>一、什么是防抖和节流</h1><p><strong>Ps</strong>: 比如搜索框，用户在输入的时候使用<code>change</code>事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器资源很强大，也不带这么玩的。</p>\n<h2 id=\"1-防抖-debounce\"><a href=\"#1-防抖-debounce\" class=\"headerlink\" title=\"1. 防抖 - debounce\"></a>1. 防抖 - debounce</h2><p>其中一种解决方案就是每次用户停止输入后，延迟超过<code>500ms</code>时，才去搜索此时的<code>String</code>，这就是防抖。</p>\n<ul>\n<li>原理：将若干个函数调用合成为一次，并在给定时间过去之后仅被调用一次。</li>\n<li>代码实现：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 维护一个 timer，用来记录当前执行函数状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 清理掉正在执行的函数，并重新执行</span></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      fn.apply(context, args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"number\">0</span>; <span class=\"comment\">// 记录当前函数调用次数</span></span><br><span class=\"line\"><span class=\"comment\">// 当用户滚动时被调用的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag++;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Number of calls: %d'</span>, flag);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 debounce 中包装我们的函数，过 2 秒触发一次</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'scroll'</span>, debounce(foo, <span class=\"number\">2000</span>));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><code>debounce</code>函数封装后，返回内部函数</li>\n<li>每一次事件被触发，都会清除当前的<code>timer</code>然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发</li>\n<li>只有当高频事件停止，最后一次事件触发的超时调用才能在<code>delay</code>时间后执行</li>\n</ol>\n</blockquote>\n<h2 id=\"2-节流-throttle\"><a href=\"#2-节流-throttle\" class=\"headerlink\" title=\"2. 节流 - throttle\"></a>2. 节流 - throttle</h2><p>另一种解决方案比 <em>防抖</em> 要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过<code>500ms</code>就查询一次此时的<code>String</code>，这就是节流。</p>\n<ul>\n<li>原理：节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</li>\n<li>代码实现有两种，一种是时间戳，另一种是定时器<br>1）时间戳实现：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args    = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> now     = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now - prev &gt;= delay)&#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于<code>delay</code>的话），而后再怎么频繁触发事件，也都是会每<code>delay</code>秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。</p>\n</blockquote>\n<p>  2）定时器实现：<br>  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到<code>delay</code>秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fucntion throttle(func, delay)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funtion()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args    = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer)&#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        func.apply(context, args);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当第一次触发事件时，肯定不会立即执行函数，而是在<code>delay</code>秒后才执行。<br>之后连续不断触发事件，也会每<code>delay</code>秒执行一次。<br>当最后一次停止触发后，由于定时器的<code>delay</code>延迟，可能还会执行一次函数。</p>\n</blockquote>\n<p>  3）综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remaining &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      func.apply(context,args);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      timer = setTimeout(func, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要在每个<code>delay</code>时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与<code>delay</code>来计算<code>remaining</code>，当<code>remaining &lt;= 0</code>时表示该执行函数了，如果还没到时间的话就设定在<code>remaining</code>时间后再触发。当然在<code>remaining</code>这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个<code>remaining</code>来判断当前状态。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、什么是防抖和节流\"><a href=\"#一、什么是防抖和节流\" class=\"headerlink\" title=\"一、什么是防抖和节流\"></a>一、什么是防抖和节流</h1><p><strong>Ps</strong>: 比如搜索框，用户在输入的时候使用<code>change</code>事件去调用搜索，如果用户每一次输入都去搜索的话，那得消耗多大的服务器资源，即使你的服务器资源很强大，也不带这么玩的。</p>\n<h2 id=\"1-防抖-debounce\"><a href=\"#1-防抖-debounce\" class=\"headerlink\" title=\"1. 防抖 - debounce\"></a>1. 防抖 - debounce</h2><p>其中一种解决方案就是每次用户停止输入后，延迟超过<code>500ms</code>时，才去搜索此时的<code>String</code>，这就是防抖。</p>\n<ul>\n<li>原理：将若干个函数调用合成为一次，并在给定时间过去之后仅被调用一次。</li>\n<li>代码实现：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 维护一个 timer，用来记录当前执行函数状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 ‘this’ 和 ‘arguments’ 获取函数的作用域和变量</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 清理掉正在执行的函数，并重新执行</span></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      fn.apply(context, args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> flag = <span class=\"number\">0</span>; <span class=\"comment\">// 记录当前函数调用次数</span></span><br><span class=\"line\"><span class=\"comment\">// 当用户滚动时被调用的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  flag++;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Number of calls: %d'</span>, flag);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 debounce 中包装我们的函数，过 2 秒触发一次</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'scroll'</span>, debounce(foo, <span class=\"number\">2000</span>));</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><code>debounce</code>函数封装后，返回内部函数</li>\n<li>每一次事件被触发，都会清除当前的<code>timer</code>然后重新设置超时并调用。这会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发</li>\n<li>只有当高频事件停止，最后一次事件触发的超时调用才能在<code>delay</code>时间后执行</li>\n</ol>\n</blockquote>\n<h2 id=\"2-节流-throttle\"><a href=\"#2-节流-throttle\" class=\"headerlink\" title=\"2. 节流 - throttle\"></a>2. 节流 - throttle</h2><p>另一种解决方案比 <em>防抖</em> 要宽松些，这时我们不想用户一味的输入，而是给用户一些搜索提示，所以在当中限制每过<code>500ms</code>就查询一次此时的<code>String</code>，这就是节流。</p>\n<ul>\n<li>原理：节流函数不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</li>\n<li>代码实现有两种，一种是时间戳，另一种是定时器<br>1）时间戳实现：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args    = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> now     = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(now - prev &gt;= delay)&#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当高频事件触发时，第一次应该会立即执行（给事件绑定函数与真正触发事件的间隔如果大于<code>delay</code>的话），而后再怎么频繁触发事件，也都是会每<code>delay</code>秒才执行一次。而当最后一次事件触发完毕后，事件也不会再被执行了。</p>\n</blockquote>\n<p>  2）定时器实现：<br>  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行；直到<code>delay</code>秒后，定时器执行执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fucntion throttle(func, delay)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funtion()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> args    = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer)&#123;</span><br><span class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        func.apply(context, args);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当第一次触发事件时，肯定不会立即执行函数，而是在<code>delay</code>秒后才执行。<br>之后连续不断触发事件，也会每<code>delay</code>秒执行一次。<br>当最后一次停止触发后，由于定时器的<code>delay</code>延迟，可能还会执行一次函数。</p>\n</blockquote>\n<p>  3）综合使用时间戳与定时器，完成一个事件触发时立即执行，触发完毕还能执行一次的节流函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(remaining &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      func.apply(context,args);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      timer = setTimeout(func, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要在每个<code>delay</code>时间中一定会执行一次函数，因此在节流函数内部使用开始时间、当前时间与<code>delay</code>来计算<code>remaining</code>，当<code>remaining &lt;= 0</code>时表示该执行函数了，如果还没到时间的话就设定在<code>remaining</code>时间后再触发。当然在<code>remaining</code>这段时间中如果又一次发生事件，那么会取消当前的计时器，并重新计算一个<code>remaining</code>来判断当前状态。</p>\n</blockquote>\n"},{"title":"JS数组专题2️⃣ ➖ 数组去重","description":"数组去重","date":"2018-09-27T02:15:18.000Z","published":1,"_content":"> 距离上次发文，已经有一段时间了，最近工作比较忙，这不眼看快双十一了，就相当于给大家一些福利吧！\n\n<div style=\"text-align: center\">\n![装逼图](https://img03.sogoucdn.com/app/a/100520021/C2FA8779E802FEF6C5454D5949F3AF44)\n</div>\n\n# 一、什么是数组去重\n\n简单说就是把数组中重复的项删除掉，你 GET 到了吗 ？下面我将简单介绍下几种基本的方法及其优缺点。\n\n# 二、方法汇总\n\n- 两层循环\n\n** 无相同值直接 `push` 进新数组，有相同的值则直接跳过本次内部循环 **\n\n```js\n/*\n * @param {Array} arr    -要去重的数组\n * @param {Array} result -初始化结果数组\n */\nconst unique = (arr, result = []) => {\n  const len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] === arr[j]) {\n        // 相等则直接跳过\n        j = ++i;\n      }\n    }\n    result.push(arr[i]);\n  }\n  return result;\n}\n```\n\n** 相同的做标记，与新数组作比较，没有则插入 **\n\n```js\n/*\n * @param {Array} arr    -要去重的数组\n * @param {Array} result -初始化结果数组\n */\nconst unique = (arr, result = []) => {\n  result.push(arr[0]);\n  const len = arr.length;\n  let rLen = result.length;\n\n  for (let i = 1; i < len; i++) {\n    let flag = false;\n    for (var j = 0; j < rLen; j++) {\n      if (arr[i] === result[j]) {\n        flag = true;\n        break;\n      }\n    }\n    if (!flag) {\n      rLen++;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\n```\n\n** 原地算法(在数组本身操作) **\n\n```js\nconst unique = arr => {\n  const len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j,1);\n        len--;\n        j--;\n      }\n    }\n  }\n  return arr;\n};\n```\n\n> 看似代码代码简单，实则内存占用高，不实用\n\n- 单层循环\n\n** 对象键不能重复 **\n\n```js\nconst unique = (arr, result = []) => {\n  const obj = {};\n  const len = arr.length;\n  for (let i = 0; i< len; i++) {\n    if (!obj[arr[i]]) {\n      // 键没有，则添加\n      obj[arr[i]] = 1;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n```\n\n> 这种方法无法判断 `'1'` 和 `1` 等类型，解决方案\b:\n> 1. 添加判断数据\b类型，比如 `typeof` ，`obj[typeof arr[i] + arr[i]]` 不过这还是判断不了 `['1']` 和 `[1]`，因为这\b被相加后，结果都一样\n> 2. 添加 `JSON.stringify()` 对结果进行去格式化，这时就可以判断了\n\n** 排序后比较前后两位，不相等则添加进新数组 **\n\n```js\nconst unique = (arr, result = []) => {\n  arr.sort();\n  result.push(arr[0]);\n  const len = arr.length;\n  let rLen = result.length;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] !== result[rLen - 1]) {\n      result.push(arr[i]);\n      rLen++;\n    }\n  }\n  return result;\n}\n```\n\n> 方法比较直接\n\n** 原地算法(排序后比较前后两位，相等则删除) **\n\n```js\nconst unique = (arr) => {\n  arr.sort();\n  let len = arr.length;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] === arr[i - 1]) {\n      arr.splice(i, 1)\n      len--;\n    }\n  }\n  return arr;\n}\n```\n\n> 不消耗额外的空间\n\n- 偷懒的节奏\n\n** `indexOf` 判断数组元素第一次出现的位置是否相同 **\n\n```js\nconst unique = (arr, result) => {\n  arr.forEach((item, index, array) => {\n    if(array.indexOf(item) === index) {\n      result.push(item);\n    }\n  });\n  return result;\n}\n\n// 使用ES6 filter\nconst unique = (arr) =>\n  arr.filter((item, index) =>  array.indexOf(item) === index);\n```\n\n> 使用ES6 方法更简洁性能更好\n\n** `indexOf` 的ES6 方法通过 `includes` 判断新数组中是否有该元素 **\n\n```js\nconst unique = (arr, result) => {\n  arr.forEach((item, index, array) => {\n    if(!result.includes(item)) {\n      // 或者 result.indexOf(item) === -1\n      result.push(item);\n    }\n  });\n  return result;\n}\n```\n\n> 建议使用 `includes`\n\n** `Map` 数据结构，不懂 `Map` 的自行解决，\b[传送门](http://es6.ruanyifeng.com/#docs/set-map#Map) **\n\n```js\nconst unique = arr => {\n  const map = new Map();\n  return arr.filter((item) => !map.has(item) && map.set(item, 1));\n}\n```\n\n> 对象关系映射可以设置不同类型的键，使之很快能收集 `arr` 中不一样的数据\n\n** `Set` 数据结构，不允许出现重复数据，而且 `Set` 支持解构 [传送门](http://es6.ruanyifeng.com/#docs/set-map#Set) **\n\n```js\nconst unique = arr => Array.from(new Set(arr));\n\n// 或者通过 ES6 的 ...解构\nconst unique = arr => [...new Set(arr)];\n```\n\n> 简单粗暴\n\n** `reduce`，给定初始值，根据数组循环给出最终值 **\n\n```js\nconst unique = (arr, result = []) => arr.reduce((prev,curr) => prev.includes(curr) ? prev : [...prev, curr], result);\n```\n\n# 三、总结\n\n方法已经说了差不多了，就看你怎么用了，其中有一些差不多的方法，只是给了说明，没给具体的例子，希望大家自己去试一下，告辞！\n","source":"_posts/js/js_array/2_unique.md","raw":"---\ntitle: JS数组专题2️⃣ ➖ 数组去重\ndescription: 数组去重\ndate: 2018-09-27 10:15:18\ntags: [ 数组, 数组去重 ]\ncategories: [ JS ]\npublished: true\n---\n> 距离上次发文，已经有一段时间了，最近工作比较忙，这不眼看快双十一了，就相当于给大家一些福利吧！\n\n<div style=\"text-align: center\">\n![装逼图](https://img03.sogoucdn.com/app/a/100520021/C2FA8779E802FEF6C5454D5949F3AF44)\n</div>\n\n# 一、什么是数组去重\n\n简单说就是把数组中重复的项删除掉，你 GET 到了吗 ？下面我将简单介绍下几种基本的方法及其优缺点。\n\n# 二、方法汇总\n\n- 两层循环\n\n** 无相同值直接 `push` 进新数组，有相同的值则直接跳过本次内部循环 **\n\n```js\n/*\n * @param {Array} arr    -要去重的数组\n * @param {Array} result -初始化结果数组\n */\nconst unique = (arr, result = []) => {\n  const len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] === arr[j]) {\n        // 相等则直接跳过\n        j = ++i;\n      }\n    }\n    result.push(arr[i]);\n  }\n  return result;\n}\n```\n\n** 相同的做标记，与新数组作比较，没有则插入 **\n\n```js\n/*\n * @param {Array} arr    -要去重的数组\n * @param {Array} result -初始化结果数组\n */\nconst unique = (arr, result = []) => {\n  result.push(arr[0]);\n  const len = arr.length;\n  let rLen = result.length;\n\n  for (let i = 1; i < len; i++) {\n    let flag = false;\n    for (var j = 0; j < rLen; j++) {\n      if (arr[i] === result[j]) {\n        flag = true;\n        break;\n      }\n    }\n    if (!flag) {\n      rLen++;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\n```\n\n** 原地算法(在数组本身操作) **\n\n```js\nconst unique = arr => {\n  const len = arr.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[i] == arr[j]) {\n        arr.splice(j,1);\n        len--;\n        j--;\n      }\n    }\n  }\n  return arr;\n};\n```\n\n> 看似代码代码简单，实则内存占用高，不实用\n\n- 单层循环\n\n** 对象键不能重复 **\n\n```js\nconst unique = (arr, result = []) => {\n  const obj = {};\n  const len = arr.length;\n  for (let i = 0; i< len; i++) {\n    if (!obj[arr[i]]) {\n      // 键没有，则添加\n      obj[arr[i]] = 1;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n};\n```\n\n> 这种方法无法判断 `'1'` 和 `1` 等类型，解决方案\b:\n> 1. 添加判断数据\b类型，比如 `typeof` ，`obj[typeof arr[i] + arr[i]]` 不过这还是判断不了 `['1']` 和 `[1]`，因为这\b被相加后，结果都一样\n> 2. 添加 `JSON.stringify()` 对结果进行去格式化，这时就可以判断了\n\n** 排序后比较前后两位，不相等则添加进新数组 **\n\n```js\nconst unique = (arr, result = []) => {\n  arr.sort();\n  result.push(arr[0]);\n  const len = arr.length;\n  let rLen = result.length;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] !== result[rLen - 1]) {\n      result.push(arr[i]);\n      rLen++;\n    }\n  }\n  return result;\n}\n```\n\n> 方法比较直接\n\n** 原地算法(排序后比较前后两位，相等则删除) **\n\n```js\nconst unique = (arr) => {\n  arr.sort();\n  let len = arr.length;\n  for (let i = 1; i < len; i++) {\n    if (arr[i] === arr[i - 1]) {\n      arr.splice(i, 1)\n      len--;\n    }\n  }\n  return arr;\n}\n```\n\n> 不消耗额外的空间\n\n- 偷懒的节奏\n\n** `indexOf` 判断数组元素第一次出现的位置是否相同 **\n\n```js\nconst unique = (arr, result) => {\n  arr.forEach((item, index, array) => {\n    if(array.indexOf(item) === index) {\n      result.push(item);\n    }\n  });\n  return result;\n}\n\n// 使用ES6 filter\nconst unique = (arr) =>\n  arr.filter((item, index) =>  array.indexOf(item) === index);\n```\n\n> 使用ES6 方法更简洁性能更好\n\n** `indexOf` 的ES6 方法通过 `includes` 判断新数组中是否有该元素 **\n\n```js\nconst unique = (arr, result) => {\n  arr.forEach((item, index, array) => {\n    if(!result.includes(item)) {\n      // 或者 result.indexOf(item) === -1\n      result.push(item);\n    }\n  });\n  return result;\n}\n```\n\n> 建议使用 `includes`\n\n** `Map` 数据结构，不懂 `Map` 的自行解决，\b[传送门](http://es6.ruanyifeng.com/#docs/set-map#Map) **\n\n```js\nconst unique = arr => {\n  const map = new Map();\n  return arr.filter((item) => !map.has(item) && map.set(item, 1));\n}\n```\n\n> 对象关系映射可以设置不同类型的键，使之很快能收集 `arr` 中不一样的数据\n\n** `Set` 数据结构，不允许出现重复数据，而且 `Set` 支持解构 [传送门](http://es6.ruanyifeng.com/#docs/set-map#Set) **\n\n```js\nconst unique = arr => Array.from(new Set(arr));\n\n// 或者通过 ES6 的 ...解构\nconst unique = arr => [...new Set(arr)];\n```\n\n> 简单粗暴\n\n** `reduce`，给定初始值，根据数组循环给出最终值 **\n\n```js\nconst unique = (arr, result = []) => arr.reduce((prev,curr) => prev.includes(curr) ? prev : [...prev, curr], result);\n```\n\n# 三、总结\n\n方法已经说了差不多了，就看你怎么用了，其中有一些差不多的方法，只是给了说明，没给具体的例子，希望大家自己去试一下，告辞！\n","slug":"js/js_array/2_unique","updated":"2018-09-27T07:53:07.635Z","_id":"cjmka5bx500180qr4e0fk8svy","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>距离上次发文，已经有一段时间了，最近工作比较忙，这不眼看快双十一了，就相当于给大家一些福利吧！</p>\n</blockquote>\n<div style=\"text-align: center\"><br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://img03.sogoucdn.com/app/a/100520021/C2FA8779E802FEF6C5454D5949F3AF44\" alt=\"装逼图\" title=\"\">\n                </div>\n                <div class=\"image-caption\">装逼图</div>\n            </figure><br></div>\n\n<h1 id=\"一、什么是数组去重\"><a href=\"#一、什么是数组去重\" class=\"headerlink\" title=\"一、什么是数组去重\"></a>一、什么是数组去重</h1><p>简单说就是把数组中重复的项删除掉，你 GET 到了吗 ？下面我将简单介绍下几种基本的方法及其优缺点。</p>\n<h1 id=\"二、方法汇总\"><a href=\"#二、方法汇总\" class=\"headerlink\" title=\"二、方法汇总\"></a>二、方法汇总</h1><ul>\n<li>两层循环</li>\n</ul>\n<p><strong> 无相同值直接 <code>push</code> 进新数组，有相同的值则直接跳过本次内部循环 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr    -要去重的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; result -初始化结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相等则直接跳过</span></span><br><span class=\"line\">        j = ++i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result.push(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong> 相同的做标记，与新数组作比较，没有则插入 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr    -要去重的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; result -初始化结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  result.push(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rLen = result.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; rLen; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === result[j]) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">      rLen++;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong> 原地算法(在数组本身操作) </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] == arr[j]) &#123;</span><br><span class=\"line\">        arr.splice(j,<span class=\"number\">1</span>);</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>看似代码代码简单，实则内存占用高，不实用</p>\n</blockquote>\n<ul>\n<li>单层循环</li>\n</ul>\n<p><strong> 对象键不能重复 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj[arr[i]]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键没有，则添加</span></span><br><span class=\"line\">      obj[arr[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方法无法判断 <code>&#39;1&#39;</code> 和 <code>1</code> 等类型，解决方案\b:</p>\n<ol>\n<li>添加判断数据\b类型，比如 <code>typeof</code> ，<code>obj[typeof arr[i] + arr[i]]</code> 不过这还是判断不了 <code>[&#39;1&#39;]</code> 和 <code>[1]</code>，因为这\b被相加后，结果都一样</li>\n<li>添加 <code>JSON.stringify()</code> 对结果进行去格式化，这时就可以判断了</li>\n</ol>\n</blockquote>\n<p><strong> 排序后比较前后两位，不相等则添加进新数组 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.sort();</span><br><span class=\"line\">  result.push(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rLen = result.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] !== result[rLen - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">      rLen++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方法比较直接</p>\n</blockquote>\n<p><strong> 原地算法(排序后比较前后两位，相等则删除) </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.sort();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === arr[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      arr.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      len--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不消耗额外的空间</p>\n</blockquote>\n<ul>\n<li>偷懒的节奏</li>\n</ul>\n<p><strong> <code>indexOf</code> 判断数组元素第一次出现的位置是否相同 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array.indexOf(item) === index) &#123;</span><br><span class=\"line\">      result.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用ES6 filter</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span></span><br><span class=\"line\">  arr.filter(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span>  array.indexOf(item) === index);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用ES6 方法更简洁性能更好</p>\n</blockquote>\n<p><strong> <code>indexOf</code> 的ES6 方法通过 <code>includes</code> 判断新数组中是否有该元素 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!result.includes(item)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 或者 result.indexOf(item) === -1</span></span><br><span class=\"line\">      result.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>建议使用 <code>includes</code></p>\n</blockquote>\n<p><strong> <code>Map</code> 数据结构，不懂 <code>Map</code> 的自行解决，\b<a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener\">传送门</a> </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.filter(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> !map.has(item) &amp;&amp; map.set(item, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对象关系映射可以设置不同类型的键，使之很快能收集 <code>arr</code> 中不一样的数据</p>\n</blockquote>\n<p><strong> <code>Set</code> 数据结构，不允许出现重复数据，而且 <code>Set</code> 支持解构 <a href=\"http://es6.ruanyifeng.com/#docs/set-map#Set\" target=\"_blank\" rel=\"noopener\">传送门</a> </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者通过 ES6 的 ...解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>简单粗暴</p>\n</blockquote>\n<p><strong> <code>reduce</code>，给定初始值，根据数组循环给出最终值 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">prev,curr</span>) =&gt;</span> prev.includes(curr) ? prev : [...prev, curr], result);</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><p>方法已经说了差不多了，就看你怎么用了，其中有一些差不多的方法，只是给了说明，没给具体的例子，希望大家自己去试一下，告辞！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>距离上次发文，已经有一段时间了，最近工作比较忙，这不眼看快双十一了，就相当于给大家一些福利吧！</p>\n</blockquote>\n<div style=\"text-align: center\"><br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://img03.sogoucdn.com/app/a/100520021/C2FA8779E802FEF6C5454D5949F3AF44\" alt=\"装逼图\" title=\"\">\n                </div>\n                <div class=\"image-caption\">装逼图</div>\n            </figure><br></div>\n\n<h1 id=\"一、什么是数组去重\"><a href=\"#一、什么是数组去重\" class=\"headerlink\" title=\"一、什么是数组去重\"></a>一、什么是数组去重</h1><p>简单说就是把数组中重复的项删除掉，你 GET 到了吗 ？下面我将简单介绍下几种基本的方法及其优缺点。</p>\n<h1 id=\"二、方法汇总\"><a href=\"#二、方法汇总\" class=\"headerlink\" title=\"二、方法汇总\"></a>二、方法汇总</h1><ul>\n<li>两层循环</li>\n</ul>\n<p><strong> 无相同值直接 <code>push</code> 进新数组，有相同的值则直接跳过本次内部循环 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr    -要去重的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; result -初始化结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相等则直接跳过</span></span><br><span class=\"line\">        j = ++i;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result.push(arr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong> 相同的做标记，与新数组作比较，没有则插入 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; arr    -要去重的数组</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Array&#125; result -初始化结果数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  result.push(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rLen = result.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; rLen; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] === result[j]) &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!flag) &#123;</span><br><span class=\"line\">      rLen++;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong> 原地算法(在数组本身操作) </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[i] == arr[j]) &#123;</span><br><span class=\"line\">        arr.splice(j,<span class=\"number\">1</span>);</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">        j--;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>看似代码代码简单，实则内存占用高，不实用</p>\n</blockquote>\n<ul>\n<li>单层循环</li>\n</ul>\n<p><strong> 对象键不能重复 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj[arr[i]]) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 键没有，则添加</span></span><br><span class=\"line\">      obj[arr[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方法无法判断 <code>&#39;1&#39;</code> 和 <code>1</code> 等类型，解决方案\b:</p>\n<ol>\n<li>添加判断数据\b类型，比如 <code>typeof</code> ，<code>obj[typeof arr[i] + arr[i]]</code> 不过这还是判断不了 <code>[&#39;1&#39;]</code> 和 <code>[1]</code>，因为这\b被相加后，结果都一样</li>\n<li>添加 <code>JSON.stringify()</code> 对结果进行去格式化，这时就可以判断了</li>\n</ol>\n</blockquote>\n<p><strong> 排序后比较前后两位，不相等则添加进新数组 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.sort();</span><br><span class=\"line\">  result.push(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> rLen = result.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] !== result[rLen - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">      rLen++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>方法比较直接</p>\n</blockquote>\n<p><strong> 原地算法(排序后比较前后两位，相等则删除) </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.sort();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[i] === arr[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">      arr.splice(i, <span class=\"number\">1</span>)</span><br><span class=\"line\">      len--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不消耗额外的空间</p>\n</blockquote>\n<ul>\n<li>偷懒的节奏</li>\n</ul>\n<p><strong> <code>indexOf</code> 判断数组元素第一次出现的位置是否相同 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array.indexOf(item) === index) &#123;</span><br><span class=\"line\">      result.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用ES6 filter</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span></span><br><span class=\"line\">  arr.filter(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span>  array.indexOf(item) === index);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使用ES6 方法更简洁性能更好</p>\n</blockquote>\n<p><strong> <code>indexOf</code> 的ES6 方法通过 <code>includes</code> 判断新数组中是否有该元素 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!result.includes(item)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 或者 result.indexOf(item) === -1</span></span><br><span class=\"line\">      result.push(item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>建议使用 <code>includes</code></p>\n</blockquote>\n<p><strong> <code>Map</code> 数据结构，不懂 <code>Map</code> 的自行解决，\b<a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\" target=\"_blank\" rel=\"noopener\">传送门</a> </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.filter(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> !map.has(item) &amp;&amp; map.set(item, <span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对象关系映射可以设置不同类型的键，使之很快能收集 <code>arr</code> 中不一样的数据</p>\n</blockquote>\n<p><strong> <code>Set</code> 数据结构，不允许出现重复数据，而且 <code>Set</code> 支持解构 <a href=\"http://es6.ruanyifeng.com/#docs/set-map#Set\" target=\"_blank\" rel=\"noopener\">传送门</a> </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者通过 ES6 的 ...解构</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> [...new <span class=\"built_in\">Set</span>(arr)];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>简单粗暴</p>\n</blockquote>\n<p><strong> <code>reduce</code>，给定初始值，根据数组循环给出最终值 </strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> unique = <span class=\"function\">(<span class=\"params\">arr, result = []</span>) =&gt;</span> arr.reduce(<span class=\"function\">(<span class=\"params\">prev,curr</span>) =&gt;</span> prev.includes(curr) ? prev : [...prev, curr], result);</span><br></pre></td></tr></table></figure>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><p>方法已经说了差不多了，就看你怎么用了，其中有一些差不多的方法，只是给了说明，没给具体的例子，希望大家自己去试一下，告辞！</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjmka46pa000a0qr4lhbcfetl","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka46pf000f0qr4vyrz9mob"},{"post_id":"cjmka46pb000b0qr4r256edsu","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka46pg000k0qr4txjouoig"},{"post_id":"cjmka46pe000e0qr4y07dobmv","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka46ph000n0qr43fakimdi"},{"post_id":"cjmka46p700060qr41tvnr969","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka46pi000o0qr4af8q25wc"},{"post_id":"cjmka46p900090qr4c6sdqmuo","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka46pi000q0qr4h7s36fgp"},{"post_id":"cjmka5bx500180qr4e0fk8svy","category_id":"cjmka46p800070qr45b2yhwv2","_id":"cjmka5bx7001b0qr44r8p3phr"}],"PostTag":[{"post_id":"cjmka46of00020qr4od30e23w","tag_id":"cjmka46ok00030qr4uvn112cx","_id":"cjmka46on00040qr4maw07tro"},{"post_id":"cjmka46p700060qr41tvnr969","tag_id":"cjmka46p900080qr4pgggr74p","_id":"cjmka46pi000r0qr4sap30qu4"},{"post_id":"cjmka46p700060qr41tvnr969","tag_id":"cjmka46ph000m0qr4vxz3fb7b","_id":"cjmka46pj000s0qr49g61cqjo"},{"post_id":"cjmka46p900090qr4c6sdqmuo","tag_id":"cjmka46p900080qr4pgggr74p","_id":"cjmka46pk000w0qr4eymu78w1"},{"post_id":"cjmka46p900090qr4c6sdqmuo","tag_id":"cjmka46ph000m0qr4vxz3fb7b","_id":"cjmka46pk000x0qr4zan16p6j"},{"post_id":"cjmka46p900090qr4c6sdqmuo","tag_id":"cjmka46pj000u0qr4qhpfpk24","_id":"cjmka46pk000z0qr459qj1dvv"},{"post_id":"cjmka46pa000a0qr4lhbcfetl","tag_id":"cjmka46pj000v0qr44tfly0ui","_id":"cjmka46pk00100qr424uqods4"},{"post_id":"cjmka46pb000b0qr4r256edsu","tag_id":"cjmka46pk000y0qr4e6wb6mkm","_id":"cjmka46pl00130qr48lb82qzb"},{"post_id":"cjmka46pb000b0qr4r256edsu","tag_id":"cjmka46pk00110qr4ny9dpiyn","_id":"cjmka46pl00140qr44udqgi1p"},{"post_id":"cjmka46pe000e0qr4y07dobmv","tag_id":"cjmka46pk00120qr41fjemwv7","_id":"cjmka46pl00160qr40fw3f4ij"},{"post_id":"cjmka46pe000e0qr4y07dobmv","tag_id":"cjmka46pl00150qr4pviq1dvk","_id":"cjmka46pl00170qr498d5crbw"},{"post_id":"cjmka5bx500180qr4e0fk8svy","tag_id":"cjmka46p900080qr4pgggr74p","_id":"cjmka5bx700190qr4i47i4kil"},{"post_id":"cjmka5bx500180qr4e0fk8svy","tag_id":"cjmka46pc000d0qr4uuiu4fga","_id":"cjmka5bx7001a0qr45fhg5z0a"}],"Tag":[{"name":"First","_id":"cjmka46ok00030qr4uvn112cx"},{"name":"数组","_id":"cjmka46p900080qr4pgggr74p"},{"name":"数组去重","_id":"cjmka46pc000d0qr4uuiu4fga"},{"name":"数组扁平化","_id":"cjmka46ph000m0qr4vxz3fb7b"},{"name":"lodash源码","_id":"cjmka46pj000u0qr4qhpfpk24"},{"name":"闭包","_id":"cjmka46pj000v0qr44tfly0ui"},{"name":"面向对象","_id":"cjmka46pk000y0qr4e6wb6mkm"},{"name":"继承","_id":"cjmka46pk00110qr4ny9dpiyn"},{"name":"防抖","_id":"cjmka46pk00120qr41fjemwv7"},{"name":"节流","_id":"cjmka46pl00150qr4pviq1dvk"}]}}